{"version":3,"sources":["../source/ItemHeights.js"],"names":["ItemHeights","getContainerElement","getState","initialize","reset","onStateUpdate","measuredItemsHeight","firstMeasuredItemIndex","undefined","lastMeasuredItemIndex","i","itemHeights","length","firstShownItemIndex","container","nodeIndex","childNodes","getBoundingClientRect","height","firstItem","secondItem","firstItemRect","secondItemRect","spacing","top","window","VirtualScrollerDebug","fromIndex","toIndex","itemSpacing","getItemSpacing","previousFirstMeasuredItemIndex","previousLastMeasuredItemIndex","firstMeasuredItemIndexHasBeenUpdated","_getItemHeight","set","previousHeight","get","count"],"mappings":";;;;;;;AAAA;;;;;;;;;;IAEqBA,W;AACpB,uBAAYC,mBAAZ,EAAiCC,QAAjC,EAA2C;AAAA;;AAC1C,SAAKD,mBAAL,GAA2BA,mBAA3B;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,UAAL;AACA;;;;iCAEY;AACZ,WAAKC,KAAL;;AACA,UAAI,KAAKF,QAAL,EAAJ,EAAqB;AACpB,aAAKG,aAAL;AACA;AACD;;;4BAEO;AACP,WAAKC,mBAAL,GAA2B,CAA3B;AACA,WAAKC,sBAAL,GAA8BC,SAA9B;AACA,WAAKC,qBAAL,GAA6BD,SAA7B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;oCACiB;AACf,UAAIE,CAAC,GAAG,CAAR;;AACA,aAAOA,CAAC,GAAG,KAAKR,QAAL,GAAgBS,WAAhB,CAA4BC,MAAvC,EAA+C;AAC9C,YAAI,KAAKV,QAAL,GAAgBS,WAAhB,CAA4BD,CAA5B,MAAmCF,SAAvC,EAAkD;AACjD,cAAI,KAAKD,sBAAL,KAAgCC,SAApC,EAA+C;AAC9C,iBAAKC,qBAAL,GAA6BC,CAAC,GAAG,CAAjC;AACA;AACA;AACD,SALD,MAKO;AACN,cAAI,KAAKH,sBAAL,KAAgCC,SAApC,EAA+C;AAC9C,iBAAKD,sBAAL,GAA8BG,CAA9B;AACA;;AACD,eAAKJ,mBAAL,IAA4B,KAAKJ,QAAL,GAAgBS,WAAhB,CAA4BD,CAA5B,CAA5B;AACA;;AACDA,QAAAA,CAAC;AACD;AACD,K,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;mCAEeA,C,EAAGG,mB,EAAqB;AACtC,UAAMC,SAAS,GAAG,KAAKb,mBAAL,EAAlB;;AACA,UAAIa,SAAJ,EAAe;AACd,YAAMC,SAAS,GAAGL,CAAC,GAAGG,mBAAtB;;AACA,YAAIE,SAAS,IAAI,CAAb,IAAkBA,SAAS,GAAGD,SAAS,CAACE,UAAV,CAAqBJ,MAAvD,EAA+D;AAC9D;AACA;AACA,iBAAOE,SAAS,CAACE,UAAV,CAAqBD,SAArB,EAAgCE,qBAAhC,GAAwDC,MAA/D;AACA;AACD;AACD;;;qCAEgB;AAChB,UAAMJ,SAAS,GAAG,KAAKb,mBAAL,EAAlB;;AACA,UAAIa,SAAJ,EAAe;AACd,YAAIA,SAAS,CAACE,UAAV,CAAqBJ,MAArB,GAA8B,CAAlC,EAAqC;AACpC,cAAMO,SAAS,GAAGL,SAAS,CAACE,UAAV,CAAqB,CAArB,CAAlB;AACA,cAAMI,UAAU,GAAGN,SAAS,CAACE,UAAV,CAAqB,CAArB,CAAnB;AACA,cAAMK,aAAa,GAAGF,SAAS,CAACF,qBAAV,EAAtB;AACA,cAAMK,cAAc,GAAGF,UAAU,CAACH,qBAAX,EAAvB;AACA,cAAMM,OAAO,GAAGD,cAAc,CAACE,GAAf,IAAsBH,aAAa,CAACG,GAAd,GAAoBH,aAAa,CAACH,MAAxD,CAAhB,CALoC,CAMpC;;AACA,cAAIO,MAAM,CAACC,oBAAX,EAAiC;AAChC,iCAAI,sBAAJ,EAA4BH,OAA5B;AACA;;AACD,iBAAOA,OAAP;AACA;AACD;AACD;AAED;AACD;AACA;AACA;AACA;AACA;;;;2BACQI,S,EAAWC,O,EAASf,mB,EAAqB;AAC/C,UAAI,KAAKX,QAAL,GAAgB2B,WAAhB,KAAgCrB,SAApC,EAA+C;AAC9C,aAAKN,QAAL,GAAgB2B,WAAhB,GAA8B,KAAKC,cAAL,EAA9B;AACA,OAH8C,CAI/C;;;AACA,UAAI,KAAKvB,sBAAL,KAAgCC,SAApC,EAA+C;AAC9C,YAAImB,SAAS,GAAG,KAAKlB,qBAAL,GAA6B,CAAzC,IAA8CmB,OAAO,GAAG,KAAKrB,sBAAL,GAA8B,CAA1F,EAA6F;AAC5F;AACA;AACA;AACA;AACA;AACA,eAAKH,KAAL,GAN4F,CAO5F;AACA;AACA;AACD;;AACD,UAAM2B,8BAA8B,GAAG,KAAKxB,sBAA5C;AACA,UAAMyB,6BAA6B,GAAG,KAAKvB,qBAA3C;AACA,UAAIwB,oCAAoC,GAAG,KAA3C;AACA,UAAIvB,CAAC,GAAGiB,SAAR;;AACA,aAAOjB,CAAC,IAAIkB,OAAZ,EAAqB;AACpB;AACA;AACA;AACA;AACA;AACA;AACC,YAAMV,MAAM,GAAG,KAAKgB,cAAL,CAAoBxB,CAApB,EAAuBG,mBAAvB,CAAf;;AACA,YAAIK,MAAM,KAAKV,SAAf,EAA0B;AACzB,eAAK2B,GAAL,CAASzB,CAAT,EAAYQ,MAAZ,EADyB,CAEzB;;AACA,cAAIa,8BAA8B,KAAKvB,SAAnC,IAAgDE,CAAC,GAAGqB,8BAAxD,EAAwF;AACvF,iBAAKzB,mBAAL,IAA4BY,MAA5B,CADuF,CAEvF;;AACA,gBAAI,CAACe,oCAAL,EAA2C;AAC1C,mBAAK1B,sBAAL,GAA8BG,CAA9B;AACAuB,cAAAA,oCAAoC,GAAG,IAAvC;AACA;AACD,WAVwB,CAWzB;;;AACA,cAAID,6BAA6B,KAAKxB,SAAlC,IAA+CE,CAAC,GAAGsB,6BAAvD,EAAsF;AACrF;AACA;AACA;AACA,gBAAIA,6BAA6B,KAAKxB,SAAtC,EAAiD;AAChD,mBAAKF,mBAAL,IAA4BY,MAA5B;AACA,aANoF,CAOrF;;;AACA,iBAAKT,qBAAL,GAA6BC,CAA7B;AACA;AACD,SA9BkB,CA+BpB;;;AACAA,QAAAA,CAAC;AACD,OAtD8C,CAuD/C;AACA;;AACA;AAED;AACD;AACA;AACA;AACA;;;;qCACkBA,C,EAAGG,mB,EAAqB;AACxC,UAAMuB,cAAc,GAAG,KAAKC,GAAL,CAAS3B,CAAT,CAAvB;;AACA,UAAMQ,MAAM,GAAG,KAAKgB,cAAL,CAAoBxB,CAApB,EAAuBG,mBAAvB,CAAf,CAFwC,CAGxC;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAIuB,cAAc,KAAK5B,SAAnB,IAAgCU,MAAM,KAAKV,SAA/C,EAA0D;AACzD;AACA;;AACD,WAAK2B,GAAL,CAASzB,CAAT,EAAYQ,MAAZ;AACA,WAAKZ,mBAAL,IAA4BY,MAAM,GAAGkB,cAArC;AACA,K,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACD;AACA;AACA;;;;iCACc;AACZ;AACA;AACA,UAAI,KAAK9B,mBAAT,EAA8B;AAC7B,eAAO,KAAKA,mBAAL,IAA4B,KAAKG,qBAAL,GAA6B,KAAKF,sBAAlC,GAA2D,CAAvF,CAAP;AACA;;AACD,aAAO,CAAP;AACA;;;wBAEGG,C,EAAG;AACN,aAAO,KAAKR,QAAL,GAAgBS,WAAhB,CAA4BD,CAA5B,CAAP;AACA;;;wBAEGA,C,EAAGQ,M,EAAQ;AACd,WAAKhB,QAAL,GAAgBS,WAAhB,CAA4BD,CAA5B,IAAiCQ,MAAjC;AACA;;;8BAESoB,K,EAAO;AAChB,UAAI,KAAK/B,sBAAL,KAAgCC,SAApC,EAA+C;AAC9C,aAAKD,sBAAL,IAA+B+B,KAA/B;AACA,aAAK7B,qBAAL,IAA8B6B,KAA9B;AACA;AACD","sourcesContent":["import log from './log'\n\nexport default class ItemHeights {\n\tconstructor(getContainerElement, getState) {\n\t\tthis.getContainerElement = getContainerElement\n\t\tthis.getState = getState\n\t\tthis.initialize()\n\t}\n\n\tinitialize() {\n\t\tthis.reset()\n\t\tif (this.getState()) {\n\t\t\tthis.onStateUpdate()\n\t\t}\n\t}\n\n\treset() {\n\t\tthis.measuredItemsHeight = 0\n\t\tthis.firstMeasuredItemIndex = undefined\n\t\tthis.lastMeasuredItemIndex = undefined\n\t}\n\n\t/**\n\t * Initializes `this.measuredItemsHeight`, `this.firstMeasuredItemIndex` and\n\t * `this.lastMeasuredItemIndex` instance variables from the `state`.\n\t * These instance variables are used when calculating \"average\" item height:\n\t * the \"average\" item height is simply `this.measuredItemsHeight` divided by\n\t * `this.lastMeasuredItemIndex` minus `this.firstMeasuredItemIndex` plus 1.\n\t * Also, `this.firstMeasuredItemIndex` and `this.lastMeasuredItemIndex`\n\t * are used to detect \"non-continuous\" scroll: the cases when scroll position\n\t * jumps from one position to a distant another position. How could that happen?\n\t * Maybe it can't, but just in case.\n\t */\n\tonStateUpdate() {\n\t\tlet i = 0\n\t\twhile (i < this.getState().itemHeights.length) {\n\t\t\tif (this.getState().itemHeights[i] === undefined) {\n\t\t\t\tif (this.firstMeasuredItemIndex !== undefined) {\n\t\t\t\t\tthis.lastMeasuredItemIndex = i - 1\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.firstMeasuredItemIndex === undefined) {\n\t\t\t\t\tthis.firstMeasuredItemIndex = i\n\t\t\t\t}\n\t\t\t\tthis.measuredItemsHeight += this.getState().itemHeights[i]\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t}\n\n\t// Seems to be no longer used.\n\t// getItemHeight(i, firstShownItemIndex) {\n\t// \tif (this.get(i)) {\n\t// \t\treturn this.get(i)\n\t// \t}\n\t// \tconst itemHeight = this._getItemHeight(i, firstShownItemIndex)\n\t// \tif (itemHeight) {\n\t// \t\tthis.set(i, itemHeight)\n\t// \t\treturn itemHeight\n\t// \t}\n\t// \treturn this.getAverage()\n\t// }\n\n\t_getItemHeight(i, firstShownItemIndex) {\n\t\tconst container = this.getContainerElement()\n\t\tif (container) {\n\t\t\tconst nodeIndex = i - firstShownItemIndex\n\t\t\tif (nodeIndex >= 0 && nodeIndex < container.childNodes.length) {\n\t\t\t\t// `offsetHeight` is not precise enough (doesn't return fractional pixels).\n\t\t\t\t// let height = container.childNodes[nodeIndex].offsetHeight\n\t\t\t\treturn container.childNodes[nodeIndex].getBoundingClientRect().height\n\t\t\t}\n\t\t}\n\t}\n\n\tgetItemSpacing() {\n\t\tconst container = this.getContainerElement()\n\t\tif (container) {\n\t\t\tif (container.childNodes.length > 1) {\n\t\t\t\tconst firstItem = container.childNodes[0]\n\t\t\t\tconst secondItem = container.childNodes[1]\n\t\t\t\tconst firstItemRect = firstItem.getBoundingClientRect()\n\t\t\t\tconst secondItemRect = secondItem.getBoundingClientRect()\n\t\t\t\tconst spacing = secondItemRect.top - (firstItemRect.top + firstItemRect.height)\n\t\t\t\t// Debugging.\n\t\t\t\tif (window.VirtualScrollerDebug) {\n\t\t\t\t\tlog('Measure item spacing', spacing)\n\t\t\t\t}\n\t\t\t\treturn spacing\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Updates item heights and item spacing.\n\t * @param  {number} fromIndex\n\t * @param  {number} toIndex\n\t * @param  {number} firstShownItemIndex\n\t */\n\tupdate(fromIndex, toIndex, firstShownItemIndex) {\n\t\tif (this.getState().itemSpacing === undefined) {\n\t\t\tthis.getState().itemSpacing = this.getItemSpacing()\n\t\t}\n\t\t// Reset `this.measuredItemsHeight` if it's not a continuous scroll.\n\t\tif (this.firstMeasuredItemIndex !== undefined) {\n\t\t\tif (fromIndex > this.lastMeasuredItemIndex + 1 || toIndex < this.firstMeasuredItemIndex - 1) {\n\t\t\t\t// // The previously measured average item height might still be\n\t\t\t\t// // more precise if it contains more measured items (\"samples\").\n\t\t\t\t// const previousAverageItemHeight = this.averageItemHeight\n\t\t\t\t// const previousAverageItemHeightSamplesCount = this.lastMeasuredItemIndex - this.firstMeasuredItemIndex + 1\n\t\t\t\t// Reset.\n\t\t\t\tthis.reset()\n\t\t\t\t// this.previousAverageItemHeight = previousAverageItemHeight\n\t\t\t\t// this.previousAverageItemHeightSamplesCount = previousAverageItemHeightSamplesCount\n\t\t\t}\n\t\t}\n\t\tconst previousFirstMeasuredItemIndex = this.firstMeasuredItemIndex\n\t\tconst previousLastMeasuredItemIndex = this.lastMeasuredItemIndex\n\t\tlet firstMeasuredItemIndexHasBeenUpdated = false\n\t\tlet i = fromIndex\n\t\twhile (i <= toIndex) {\n\t\t\t// Recalculate item heights because item height might change\n\t\t\t// after showing it compared to what it was when hiding it.\n\t\t\t// For example, a YouTube video might have been expanded\n\t\t\t// and then the item is hidden and it's state is reset\n\t\t\t// and when it's shown again the YouTube video is not expanded.\n\t\t\t// if (this.get(i) === undefined) {\n\t\t\t\tconst height = this._getItemHeight(i, firstShownItemIndex)\n\t\t\t\tif (height !== undefined) {\n\t\t\t\t\tthis.set(i, height)\n\t\t\t\t\t// Update new items height (before).\n\t\t\t\t\tif (previousFirstMeasuredItemIndex === undefined || i < previousFirstMeasuredItemIndex) {\n\t\t\t\t\t\tthis.measuredItemsHeight += height\n\t\t\t\t\t\t// Update first measured item index.\n\t\t\t\t\t\tif (!firstMeasuredItemIndexHasBeenUpdated) {\n\t\t\t\t\t\t\tthis.firstMeasuredItemIndex = i\n\t\t\t\t\t\t\tfirstMeasuredItemIndexHasBeenUpdated = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Update new items height (after).\n\t\t\t\t\tif (previousLastMeasuredItemIndex === undefined || i > previousLastMeasuredItemIndex) {\n\t\t\t\t\t\t// If `previousLastMeasuredItemIndex` is `undefined`\n\t\t\t\t\t\t// then `previousFirstMeasuredItemIndex` is also `undefined`\n\t\t\t\t\t\t// which means that `this.measuredItemsHeight` has already been updated.\n\t\t\t\t\t\tif (previousLastMeasuredItemIndex !== undefined) {\n\t\t\t\t\t\t\tthis.measuredItemsHeight += height\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Update last measured item index.\n\t\t\t\t\t\tthis.lastMeasuredItemIndex = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t// }\n\t\t\ti++\n\t\t}\n\t\t// // Update average item height.\n\t\t// this.updateAverageItemHeight()\n\t}\n\n\t/**\n\t * Re-measures item height.\n\t * @param  {number} i — Item index.\n\t * @param  {number} firstShownItemIndex\n\t */\n\tupdateItemHeight(i, firstShownItemIndex) {\n\t\tconst previousHeight = this.get(i)\n\t\tconst height = this._getItemHeight(i, firstShownItemIndex)\n\t\t// The items might not have rendered at all,\n\t\t// for example, when using React, because\n\t\t// React performs DOM updates asynchronously\n\t\t// and if the user scrolls fast enough\n\t\t// React might not have rendered the item\n\t\t// since it has become visible till it became no longer visible.\n\t\tif (previousHeight === undefined || height === undefined) {\n\t\t\treturn\n\t\t}\n\t\tthis.set(i, height)\n\t\tthis.measuredItemsHeight += height - previousHeight\n\t}\n\n\t// /**\n\t//  * \"Average\" item height is stored as an instance variable.\n\t//  * For example, for caching, so that it isn't calculated every time it's requested.\n\t//  * But that would be negligible performance gain, not really worth the extra code.\n\t//  * Another thing it's stored for as an instance variable is\n\t//  * keeping \"previous\" \"average\" item height, because it can be more precise\n\t//  * than the newly calculated \"average\" item height, provided it had\n\t//  * more \"samples\" (measured items). The newly calculated average item height\n\t//  * could get less samples in a scenario when the scroll somehow jumps\n\t//  * from one position to some other distant position: in that case previous\n\t//  * \"total measured items height\" is discarded and the new one is initialized.\n\t//  * Could such situation happen in real life? I guess, it's unlikely.\n\t//  * So I'm commenting out this code, but still keeping it just in case.\n\t//  */\n\t// updateAverageItemHeight() {\n\t// \tthis.averageItemHeightSamplesCount = this.lastMeasuredItemIndex - this.firstMeasuredItemIndex + 1\n\t// \tthis.averageItemHeight = this.measuredItemsHeight / this.averageItemHeightSamplesCount\n\t// }\n\t//\n\t// /**\n\t//  * Public API: is called by `VirtualScroller`.\n\t//  * @return {number}\n\t//  */\n\t// getAverage() {\n\t// \t// Previously measured average item height might still be\n\t// \t// more precise if it contains more measured items (\"samples\").\n\t// \tif (this.previousAverageItemHeight) {\n\t// \t\tif (this.previousAverageItemHeightSamplesCount > this.averageItemHeightSamplesCount) {\n\t// \t\t\treturn this.previousAverageItemHeight\n\t// \t\t}\n\t// \t}\n\t// \treturn this.averageItemHeight || 0\n\t// }\n\n\t/**\n\t * Public API: is called by `VirtualScroller`.\n\t * @return {number}\n\t */\n\tgetAverage() {\n\t\t// When `this.measuredItemsHeight` is `0`\n\t\t// then `this.lastMeasuredItemIndex` and `this.firstMeasuredItemIndex` are `undefined`.\n\t\tif (this.measuredItemsHeight) {\n\t\t\treturn this.measuredItemsHeight / (this.lastMeasuredItemIndex - this.firstMeasuredItemIndex + 1)\n\t\t}\n\t\treturn 0\n\t}\n\n\tget(i) {\n\t\treturn this.getState().itemHeights[i]\n\t}\n\n\tset(i, height) {\n\t\tthis.getState().itemHeights[i] = height\n\t}\n\n\tonPrepend(count) {\n\t\tif (this.firstMeasuredItemIndex !== undefined) {\n\t\t\tthis.firstMeasuredItemIndex += count\n\t\t\tthis.lastMeasuredItemIndex += count\n\t\t}\n\t}\n}"],"file":"ItemHeights.js"}