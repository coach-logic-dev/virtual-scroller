{"version":3,"file":"virtual-scroller-dom.js","sources":["../node_modules/raf/index.js","../node_modules/performance-now/lib/performance-now.js","../node_modules/request-animation-frame-timeout/modules/index.js","../modules/ScrollableContainer.js","../modules/DOM.js","../modules/utility.js","../modules/tbody.js","../modules/log.js","../modules/ItemHeights.js","../modules/shallowEqual.js","../modules/VirtualScroller.js","../modules/DOMVirtualScroller.js"],"sourcesContent":["var now = require('performance-now')\n  , root = typeof window === 'undefined' ? global : window\n  , vendors = ['moz', 'webkit']\n  , suffix = 'AnimationFrame'\n  , raf = root['request' + suffix]\n  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]\n\nfor(var i = 0; !raf && i < vendors.length; i++) {\n  raf = root[vendors[i] + 'Request' + suffix]\n  caf = root[vendors[i] + 'Cancel' + suffix]\n      || root[vendors[i] + 'CancelRequest' + suffix]\n}\n\n// Some versions of FF have rAF but not cAF\nif(!raf || !caf) {\n  var last = 0\n    , id = 0\n    , queue = []\n    , frameDuration = 1000 / 60\n\n  raf = function(callback) {\n    if(queue.length === 0) {\n      var _now = now()\n        , next = Math.max(0, frameDuration - (_now - last))\n      last = next + _now\n      setTimeout(function() {\n        var cp = queue.slice(0)\n        // Clear queue here to prevent\n        // callbacks from appending listeners\n        // to the current frame's queue\n        queue.length = 0\n        for(var i = 0; i < cp.length; i++) {\n          if(!cp[i].cancelled) {\n            try{\n              cp[i].callback(last)\n            } catch(e) {\n              setTimeout(function() { throw e }, 0)\n            }\n          }\n        }\n      }, Math.round(next))\n    }\n    queue.push({\n      handle: ++id,\n      callback: callback,\n      cancelled: false\n    })\n    return id\n  }\n\n  caf = function(handle) {\n    for(var i = 0; i < queue.length; i++) {\n      if(queue[i].handle === handle) {\n        queue[i].cancelled = true\n      }\n    }\n  }\n}\n\nmodule.exports = function(fn) {\n  // Wrap in a new function to prevent\n  // `cancel` potentially being assigned\n  // to the native rAF function\n  return raf.call(root, fn)\n}\nmodule.exports.cancel = function() {\n  caf.apply(root, arguments)\n}\nmodule.exports.polyfill = function(object) {\n  if (!object) {\n    object = root;\n  }\n  object.requestAnimationFrame = raf\n  object.cancelAnimationFrame = caf\n}\n","// Generated by CoffeeScript 1.12.2\n(function() {\n  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;\n\n  if ((typeof performance !== \"undefined\" && performance !== null) && performance.now) {\n    module.exports = function() {\n      return performance.now();\n    };\n  } else if ((typeof process !== \"undefined\" && process !== null) && process.hrtime) {\n    module.exports = function() {\n      return (getNanoSeconds() - nodeLoadTime) / 1e6;\n    };\n    hrtime = process.hrtime;\n    getNanoSeconds = function() {\n      var hr;\n      hr = hrtime();\n      return hr[0] * 1e9 + hr[1];\n    };\n    moduleLoadTime = getNanoSeconds();\n    upTime = process.uptime() * 1e9;\n    nodeLoadTime = moduleLoadTime - upTime;\n  } else if (Date.now) {\n    module.exports = function() {\n      return Date.now() - loadTime;\n    };\n    loadTime = Date.now();\n  } else {\n    module.exports = function() {\n      return new Date().getTime() - loadTime;\n    };\n    loadTime = new Date().getTime();\n  }\n\n}).call(this);\n\n//# sourceMappingURL=performance-now.js.map\n","import requestAnimationFrame from 'raf';\nvar cancelAnimationFrame = requestAnimationFrame.cancel;\nexport function setTimeout(callback, delay) {\n  var startedAt = Date.now();\n  var animationFrame = requestAnimationFrame(tick);\n\n  function tick() {\n    if (Date.now() - startedAt >= delay) {\n      callback();\n    } else {\n      animationFrame = requestAnimationFrame(tick);\n    }\n  }\n\n  return {\n    clear: function clear() {\n      return cancelAnimationFrame(animationFrame);\n    }\n  };\n}\nexport function clearTimeout(timeout) {\n  if (timeout) {\n    timeout.clear();\n  }\n}\n//# sourceMappingURL=index.js.map","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { getScrollY as _getScrollY, getScreenHeight, getScreenWidth } from './DOM';\n\nvar ScrollableContainer =\n/*#__PURE__*/\nfunction () {\n  function ScrollableContainer(element) {\n    _classCallCheck(this, ScrollableContainer);\n\n    this.element = element;\n  }\n\n  _createClass(ScrollableContainer, [{\n    key: \"getScrollY\",\n    value: function getScrollY() {\n      return this.element.scrollTop;\n    }\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(scrollX, scrollY) {\n      this.element.scrollTo(scrollX, scrollY);\n    }\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return this.element.offsetWidth;\n    }\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      // if (!this.element && !precise) {\n      // \treturn getScreenHeight()\n      // }\n      return this.element.offsetHeight;\n    }\n  }, {\n    key: \"getContentHeight\",\n    value: function getContentHeight() {\n      return this.element.scrollHeight;\n    }\n  }, {\n    key: \"getTopOffset\",\n    value: function getTopOffset(element) {\n      var scrollableContainerTop = this.element.getBoundingClientRect().top;\n      var scrollableContainerBorderTopWidth = this.element.clientTop;\n      var top = element.getBoundingClientRect().top;\n      return top - scrollableContainerTop + this.getScrollY() - scrollableContainerBorderTopWidth;\n    } // isVisible() {\n    // \tconst { top, bottom } = this.element.getBoundingClientRect()\n    // \treturn bottom > 0 && top < getScreenHeight()\n    // }\n\n  }, {\n    key: \"addScrollListener\",\n    value: function addScrollListener(listener) {\n      var _this = this;\n\n      this.element.addEventListener('scroll', listener);\n      return function () {\n        return _this.element.removeEventListener('scroll', listener);\n      };\n    }\n  }, {\n    key: \"onResize\",\n    value: function onResize(_onResize) {\n      var _this2 = this;\n\n      // Could somehow track DOM Element size.\n      // For now, `scrollableContainer` is supposed to have constant width and height.\n      // (unless window is resized).\n      // https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver\n      // https://web.dev/resize-observer/\n      var unobserve;\n\n      if (typeof ResizeObserver !== 'undefined') {\n        var resizeObserver = new ResizeObserver(function (entries) {\n          for (var _iterator = entries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n            var _ref;\n\n            if (_isArray) {\n              if (_i >= _iterator.length) break;\n              _ref = _iterator[_i++];\n            } else {\n              _i = _iterator.next();\n              if (_i.done) break;\n              _ref = _i.value;\n            }\n\n            var entry = _ref;\n            // // If `entry.contentBoxSize` property is supported by the web browser.\n            // if (entry.contentBoxSize) {\n            // \t// https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry/contentBoxSize\n            // \tconst width = entry.contentBoxSize.inlineSize\n            // \tconst height = entry.contentBoxSize.blockSize\n            // }\n            return _onResize();\n          }\n        });\n        resizeObserver.observe(this.element);\n\n        unobserve = function unobserve() {\n          return resizeObserver.unobserve(_this2.element);\n        };\n      } // I guess, if window is resized, `onResize()` will be triggered twice:\n      // once for window resize, and once for the scrollable container resize.\n      // But `onResize()` also has an internal check: if the size didn't change\n      // then it's not run.\n\n\n      var unlistenWindowResize = new ScrollableWindowContainer().onResize(_onResize);\n      return function () {\n        if (unobserve) {\n          unobserve();\n        }\n\n        unlistenWindowResize();\n      };\n    }\n  }]);\n\n  return ScrollableContainer;\n}();\n\nexport { ScrollableContainer as default };\nexport var ScrollableWindowContainer =\n/*#__PURE__*/\nfunction (_ScrollableContainer) {\n  _inherits(ScrollableWindowContainer, _ScrollableContainer);\n\n  function ScrollableWindowContainer() {\n    _classCallCheck(this, ScrollableWindowContainer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ScrollableWindowContainer).call(this, window));\n  }\n\n  _createClass(ScrollableWindowContainer, [{\n    key: \"getScrollY\",\n    value: function getScrollY() {\n      return _getScrollY();\n    }\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return getScreenWidth();\n    }\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return getScreenHeight();\n    }\n  }, {\n    key: \"getContentHeight\",\n    value: function getContentHeight() {\n      return document.documentElement.scrollHeight;\n    }\n  }, {\n    key: \"getTopOffset\",\n    value: function getTopOffset(element) {\n      var borderTopWidth = document.clientTop || document.body.clientTop || 0;\n      return element.getBoundingClientRect().top + this.getScrollY() - borderTopWidth;\n    }\n  }, {\n    key: \"onResize\",\n    value: function onResize(_onResize2) {\n      window.addEventListener('resize', _onResize2);\n      return function () {\n        return window.removeEventListener('resize', _onResize2);\n      };\n    } // isVisible() {\n    // \treturn true\n    // }\n\n  }]);\n\n  return ScrollableWindowContainer;\n}(ScrollableContainer);\n//# sourceMappingURL=ScrollableContainer.js.map","function getScrollX() {\n  // `window.scrollX` is not supported by Internet Explorer.\n  return window.pageXOffset;\n}\n\nexport function getScrollY() {\n  // `window.scrollY` is not supported by Internet Explorer.\n  return window.pageYOffset;\n}\nexport function clearElement(element) {\n  while (element.firstChild) {\n    element.removeChild(element.firstChild);\n  }\n} // export function getScreenWidth() {\n// \t// Doesn't correctly reflect page zoom in iOS Safari.\n// \t// (doesn't scale screen width accordingly).\n// \t// (but does reflect page zoom in desktop Chrome).\n// \treturn document.documentElement.clientWidth\n// }\n// https://javascript.info/size-and-scroll-window\n// `<!DOCTYPE html>` may be required in order for this to work correctly.\n// Includes scrollbar (if any).\n\nexport function getScreenWidth() {\n  // Correctly reflects page zoom in iOS Safari.\n  // (scales screen width accordingly).\n  // But, includes scrollbar (if any).\n  return window.innerWidth;\n} // export function getScreenHeight() {\n// \t// Doesn't support iOS Safari's dynamically shown/hidden\n// \t// top URL bar and bottom actions bar.\n// \t// https://codesandbox.io/s/elegant-fog-iddrh\n// \t// Tested in IE 11.\n// \t// It also doesn't correctly reflect page zoom in iOS Safari.\n// \t// (doesn't scale screen height accordingly).\n// \t// (but does reflect page zoom in desktop Chrome).\n// \treturn document.documentElement.clientHeight\n// }\n// https://javascript.info/size-and-scroll-window\n// `<!DOCTYPE html>` is required in order for this to work correctly.\n// Without it, the returned height would be the height of the entire document.\n// Includes scrollbar (if any).\n\nexport function getScreenHeight() {\n  // This variant of `getScreenHeight()`\n  // supports iOS Safari's dynamically shown/hidden\n  // top URL bar and bottom actions bar.\n  // https://codesandbox.io/s/elegant-fog-iddrh\n  // Tested in IE 11.\n  // It also correctly reflects page zoom in iOS Safari.\n  // (scales screen height accordingly).\n  // But, includes scrollbar (if any).\n  return window.innerHeight;\n} // // This variant of `getScreenHeight()`\n// // supports iOS Safari's dynamically shown/hidden\n// // top URL bar and bottom actions bar.\n// // https://codesandbox.io/s/elegant-fog-iddrh\n// // Tested in IE 11.\n// // It doesn't correctly reflect page zoom in iOS Safari.\n// // (doesn't scale screen height accordingly).\n// // (but does reflect page zoom in desktop Chrome).\n// function getScreenHeight() {\n// \tconst div = document.createElement('div')\n// \tdiv.style.position = 'fixed'\n// \tdiv.style.left = 0\n// \tdiv.style.top = 0\n// \tdiv.style.right = 0\n// \tdiv.style.bottom = 0\n// \tdiv.style.zIndex = -1\n// \tdocument.body.appendChild(div)\n// \tconst height = div.clientHeight\n// \tdocument.body.removeChild(div)\n// \treturn height\n// }\n//# sourceMappingURL=DOM.js.map","/**\n * Same as `lodash`'s `throttle()` for functions with no arguments.\n * @param  {function} func\n * @param  {number} interval\n * @return {function}\n */\nexport function throttle(func, interval) {\n  var timeout;\n  var executedAt = 0;\n\n  var scheduled = function scheduled() {\n    timeout = undefined;\n    executedAt = Date.now();\n    func();\n  };\n\n  return function () {\n    var now = Date.now();\n    var remaining = interval - (now - executedAt);\n\n    if (remaining <= 0) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = undefined;\n      }\n\n      executedAt = now;\n      func();\n    } else if (!timeout) {\n      timeout = setTimeout(scheduled, remaining);\n    }\n  };\n}\n/**\n * Same as `lodash`'s `debounce()` for functions with no arguments.\n * @param  {function} func\n * @param  {number} interval\n * @return {function}\n */\n\nexport function debounce(func, interval) {\n  var timeout;\n  return function () {\n    var _this = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      return func.apply(_this, args);\n    }, interval);\n  };\n}\n/**\n * Rounds coordinates upto 4th decimal place (after dot) and appends \"px\".\n * Small numbers could be printed as `\"1.2345e-50\"` unless rounded:\n * that would be invalid \"px\" value in CSS.\n * @param {number}\n * @return {string}\n */\n\nexport function px(number) {\n  // Fractional pixels are used on \"retina\" screens.\n  return number.toFixed(2) + 'px';\n}\n//# sourceMappingURL=utility.js.map","import { px } from './utility';\nvar NOT_SUPPORTED_MESSAGE = '[virtual-scroller] It looks like you\\'re using Internet Explorer which doesn\\'t support CSS variables required for a <tbody/> container. VirtualScroller has been switched into \"bypass\" mode (render all items). See: https://gitlab.com/catamphetamine/virtual-scroller/-/issues/1';\nexport function supportsTbody() {\n  // Detect Internet Explorer.\n  // https://stackoverflow.com/questions/19999388/check-if-user-is-using-ie\n  // `documentMode` is an IE-only property.\n  // Supports IE 9-11. Maybe even IE 8.\n  // http://msdn.microsoft.com/en-us/library/ie/cc196988(v=vs.85).aspx\n  if (typeof window !== 'undefined' && window.document.documentMode) {\n    // CSS variables aren't supported in Internet Explorer.\n    return false;\n  }\n\n  return true;\n}\nexport function reportTbodyIssue() {\n  if (typeof window !== 'undefined') {\n    // In a web browser.\n    setTimeout(function () {\n      // Throw an error in a timeout so that it doesn't interrupt the application's flow.\n      // At the same time, the error could be spotted in the console or in error monitoring software.\n      throw new Error(NOT_SUPPORTED_MESSAGE);\n    }, 0);\n  } else {\n    // On a server.\n    console.error(NOT_SUPPORTED_MESSAGE);\n  }\n}\nexport function addTbodyStyles(tbody) {\n  // `classList.add` is supported in Internet Explorer 10+.\n  tbody.classList.add('VirtualScroller');\n  var style = document.getElementById('VirtualScrollerStyle');\n\n  if (!style) {\n    style = document.createElement('style');\n    style.id = 'VirtualScrollerStyle'; // CSS variables aren't supported in Internet Explorer.\n\n    style.innerText = \"\\n\\t\\t\\ttbody.VirtualScroller:before {\\n\\t\\t\\t\\tcontent: '';\\n\\t\\t\\t\\tdisplay: table-row;\\n\\t\\t\\t\\theight: var(--VirtualScroller-paddingTop);\\n\\t\\t\\t}\\n\\t\\t\\ttbody.VirtualScroller:after {\\n\\t\\t\\t\\tcontent: '';\\n\\t\\t\\t\\tdisplay: table-row;\\n\\t\\t\\t\\theight: var(--VirtualScroller-paddingBottom);\\n\\t\\t\\t}\\n\\t\\t\".replace(/[\\n\\t]/g, '');\n    document.head.appendChild(style);\n  }\n}\nexport function setTbodyPadding(tbody, beforeItemsHeight, afterItemsHeight) {\n  // CSS variables aren't supported in Internet Explorer.\n  tbody.style.setProperty('--VirtualScroller-paddingTop', px(beforeItemsHeight));\n  tbody.style.setProperty('--VirtualScroller-paddingBottom', px(afterItemsHeight));\n}\n//# sourceMappingURL=tbody.js.map","function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nexport default function log() {\n  if (isDebug()) {\n    var _console;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    (_console = console).log.apply(_console, _toConsumableArray(['[virtual-scroller]'].concat(args)));\n  }\n}\nexport function isDebug() {\n  return typeof window !== 'undefined' && window.VirtualScrollerDebug;\n}\n//# sourceMappingURL=log.js.map","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport log from './log';\n\nvar ItemHeights =\n/*#__PURE__*/\nfunction () {\n  function ItemHeights(getContainerElement, getState) {\n    _classCallCheck(this, ItemHeights);\n\n    this.getContainerElement = getContainerElement;\n    this.getState = getState;\n    this.initialize();\n  }\n\n  _createClass(ItemHeights, [{\n    key: \"initialize\",\n    value: function initialize() {\n      this.reset();\n\n      if (this.getState()) {\n        this.onStateUpdate();\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.measuredItemsHeight = 0;\n      this.firstMeasuredItemIndex = undefined;\n      this.lastMeasuredItemIndex = undefined;\n    }\n    /**\n     * Initializes `this.measuredItemsHeight`, `this.firstMeasuredItemIndex` and\n     * `this.lastMeasuredItemIndex` instance variables from the `state`.\n     * These instance variables are used when calculating \"average\" item height:\n     * the \"average\" item height is simply `this.measuredItemsHeight` divided by\n     * `this.lastMeasuredItemIndex` minus `this.firstMeasuredItemIndex` plus 1.\n     * Also, `this.firstMeasuredItemIndex` and `this.lastMeasuredItemIndex`\n     * are used to detect \"non-continuous\" scroll: the cases when scroll position\n     * jumps from one position to a distant another position. How could that happen?\n     * Maybe it can't, but just in case.\n     */\n\n  }, {\n    key: \"onStateUpdate\",\n    value: function onStateUpdate() {\n      var i = 0;\n\n      while (i < this.getState().itemHeights.length) {\n        if (this.getState().itemHeights[i] === undefined) {\n          if (this.firstMeasuredItemIndex !== undefined) {\n            this.lastMeasuredItemIndex = i - 1;\n            break;\n          }\n        } else {\n          if (this.firstMeasuredItemIndex === undefined) {\n            this.firstMeasuredItemIndex = i;\n          }\n\n          this.measuredItemsHeight += this.getState().itemHeights[i];\n        }\n\n        i++;\n      }\n    } // Seems to be no longer used.\n    // getItemHeight(i, firstShownItemIndex) {\n    // \tif (this.get(i)) {\n    // \t\treturn this.get(i)\n    // \t}\n    // \tconst itemHeight = this._getItemHeight(i, firstShownItemIndex)\n    // \tif (itemHeight) {\n    // \t\tthis.set(i, itemHeight)\n    // \t\treturn itemHeight\n    // \t}\n    // \treturn this.getAverage()\n    // }\n\n  }, {\n    key: \"_getItemHeight\",\n    value: function _getItemHeight(i, firstShownItemIndex) {\n      var container = this.getContainerElement();\n\n      if (container) {\n        var nodeIndex = i - firstShownItemIndex;\n\n        if (nodeIndex >= 0 && nodeIndex < container.childNodes.length) {\n          // `offsetHeight` is not precise enough (doesn't return fractional pixels).\n          // let height = container.childNodes[nodeIndex].offsetHeight\n          return container.childNodes[nodeIndex].getBoundingClientRect().height;\n        }\n      }\n    }\n  }, {\n    key: \"getItemSpacing\",\n    value: function getItemSpacing() {\n      var container = this.getContainerElement();\n\n      if (container) {\n        if (container.childNodes.length > 1) {\n          var firstItem = container.childNodes[0];\n          var secondItem = container.childNodes[1];\n          var firstItemRect = firstItem.getBoundingClientRect();\n          var secondItemRect = secondItem.getBoundingClientRect();\n          var spacing = secondItemRect.top - (firstItemRect.top + firstItemRect.height); // Debugging.\n\n          if (window.VirtualScrollerDebug) {\n            log('Measure item spacing', spacing);\n          }\n\n          return spacing;\n        }\n      }\n    }\n    /**\n     * Updates item heights and item spacing.\n     * @param  {number} fromIndex\n     * @param  {number} toIndex\n     * @param  {number} firstShownItemIndex\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(fromIndex, toIndex, firstShownItemIndex) {\n      if (this.getState().itemSpacing === undefined) {\n        this.getState().itemSpacing = this.getItemSpacing();\n      } // Reset `this.measuredItemsHeight` if it's not a continuous scroll.\n\n\n      if (this.firstMeasuredItemIndex !== undefined) {\n        if (fromIndex > this.lastMeasuredItemIndex + 1 || toIndex < this.firstMeasuredItemIndex - 1) {\n          // // The previously measured average item height might still be\n          // // more precise if it contains more measured items (\"samples\").\n          // const previousAverageItemHeight = this.averageItemHeight\n          // const previousAverageItemHeightSamplesCount = this.lastMeasuredItemIndex - this.firstMeasuredItemIndex + 1\n          // Reset.\n          this.reset(); // this.previousAverageItemHeight = previousAverageItemHeight\n          // this.previousAverageItemHeightSamplesCount = previousAverageItemHeightSamplesCount\n        }\n      }\n\n      var previousFirstMeasuredItemIndex = this.firstMeasuredItemIndex;\n      var previousLastMeasuredItemIndex = this.lastMeasuredItemIndex;\n      var firstMeasuredItemIndexHasBeenUpdated = false;\n      var i = fromIndex;\n\n      while (i <= toIndex) {\n        // Recalculate item heights because item height might change\n        // after showing it compared to what it was when hiding it.\n        // For example, a YouTube video might have been expanded\n        // and then the item is hidden and it's state is reset\n        // and when it's shown again the YouTube video is not expanded.\n        // if (this.get(i) === undefined) {\n        var height = this._getItemHeight(i, firstShownItemIndex);\n\n        if (height !== undefined) {\n          this.set(i, height); // Update new items height (before).\n\n          if (previousFirstMeasuredItemIndex === undefined || i < previousFirstMeasuredItemIndex) {\n            this.measuredItemsHeight += height; // Update first measured item index.\n\n            if (!firstMeasuredItemIndexHasBeenUpdated) {\n              this.firstMeasuredItemIndex = i;\n              firstMeasuredItemIndexHasBeenUpdated = true;\n            }\n          } // Update new items height (after).\n\n\n          if (previousLastMeasuredItemIndex === undefined || i > previousLastMeasuredItemIndex) {\n            // If `previousLastMeasuredItemIndex` is `undefined`\n            // then `previousFirstMeasuredItemIndex` is also `undefined`\n            // which means that `this.measuredItemsHeight` has already been updated.\n            if (previousLastMeasuredItemIndex !== undefined) {\n              this.measuredItemsHeight += height;\n            } // Update last measured item index.\n\n\n            this.lastMeasuredItemIndex = i;\n          }\n        } // }\n\n\n        i++;\n      } // // Update average item height.\n      // this.updateAverageItemHeight()\n\n    }\n    /**\n     * Re-measures item height.\n     * @param  {number} i — Item index.\n     * @param  {number} firstShownItemIndex\n     */\n\n  }, {\n    key: \"updateItemHeight\",\n    value: function updateItemHeight(i, firstShownItemIndex) {\n      var previousHeight = this.get(i);\n\n      var height = this._getItemHeight(i, firstShownItemIndex); // The items might not have rendered at all,\n      // for example, when using React, because\n      // React performs DOM updates asynchronously\n      // and if the user scrolls fast enough\n      // React might not have rendered the item\n      // since it has become visible till it became no longer visible.\n\n\n      if (previousHeight === undefined || height === undefined) {\n        return;\n      }\n\n      this.set(i, height);\n      this.measuredItemsHeight += height - previousHeight;\n    } // /**\n    //  * \"Average\" item height is stored as an instance variable.\n    //  * For example, for caching, so that it isn't calculated every time it's requested.\n    //  * But that would be negligible performance gain, not really worth the extra code.\n    //  * Another thing it's stored for as an instance variable is\n    //  * keeping \"previous\" \"average\" item height, because it can be more precise\n    //  * than the newly calculated \"average\" item height, provided it had\n    //  * more \"samples\" (measured items). The newly calculated average item height\n    //  * could get less samples in a scenario when the scroll somehow jumps\n    //  * from one position to some other distant position: in that case previous\n    //  * \"total measured items height\" is discarded and the new one is initialized.\n    //  * Could such situation happen in real life? I guess, it's unlikely.\n    //  * So I'm commenting out this code, but still keeping it just in case.\n    //  */\n    // updateAverageItemHeight() {\n    // \tthis.averageItemHeightSamplesCount = this.lastMeasuredItemIndex - this.firstMeasuredItemIndex + 1\n    // \tthis.averageItemHeight = this.measuredItemsHeight / this.averageItemHeightSamplesCount\n    // }\n    //\n    // /**\n    //  * Public API: is called by `VirtualScroller`.\n    //  * @return {number}\n    //  */\n    // getAverage() {\n    // \t// Previously measured average item height might still be\n    // \t// more precise if it contains more measured items (\"samples\").\n    // \tif (this.previousAverageItemHeight) {\n    // \t\tif (this.previousAverageItemHeightSamplesCount > this.averageItemHeightSamplesCount) {\n    // \t\t\treturn this.previousAverageItemHeight\n    // \t\t}\n    // \t}\n    // \treturn this.averageItemHeight || 0\n    // }\n\n    /**\n     * Public API: is called by `VirtualScroller`.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getAverage\",\n    value: function getAverage() {\n      // When `this.measuredItemsHeight` is `0`\n      // then `this.lastMeasuredItemIndex` and `this.firstMeasuredItemIndex` are `undefined`.\n      if (this.measuredItemsHeight) {\n        return this.measuredItemsHeight / (this.lastMeasuredItemIndex - this.firstMeasuredItemIndex + 1);\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"get\",\n    value: function get(i) {\n      return this.getState().itemHeights[i];\n    }\n  }, {\n    key: \"set\",\n    value: function set(i, height) {\n      this.getState().itemHeights[i] = height;\n    }\n  }, {\n    key: \"onPrepend\",\n    value: function onPrepend(count) {\n      if (this.firstMeasuredItemIndex !== undefined) {\n        this.firstMeasuredItemIndex += count;\n        this.lastMeasuredItemIndex += count;\n      }\n    }\n  }]);\n\n  return ItemHeights;\n}();\n\nexport { ItemHeights as default };\n//# sourceMappingURL=ItemHeights.js.map","// https://github.com/lodash/lodash/issues/2340\n// https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/shallowEqual.js\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule shallowEqual\n * @typechecks\n * @flow\n */\n\n/*eslint-disable no-self-compare */\n'use strict';\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\n\nfunction is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\n\n\nexport default function shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (_typeof(objA) !== 'object' || objA === null || _typeof(objB) !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  } // Test for A's keys different from B.\n\n\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n//# sourceMappingURL=shallowEqual.js.map","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// For some weird reason, in Chrome, `setTimeout()` would lag up to a second (or more) behind.\n// Turns out, Chrome developers have deprecated `setTimeout()` API entirely without asking anyone.\n// Replacing `setTimeout()` with `requestAnimationFrame()` can work around that Chrome bug.\n// https://github.com/bvaughn/react-virtualized/issues/722\nimport { setTimeout, clearTimeout } from \"request-animation-frame-timeout\";\nimport ScrollableContainer, { ScrollableWindowContainer } from \"./ScrollableContainer\";\nimport { supportsTbody, reportTbodyIssue, addTbodyStyles, setTbodyPadding } from \"./tbody\";\nimport ItemHeights from \"./ItemHeights\";\nimport { clearElement } from \"./DOM\";\nimport log, { isDebug } from \"./log\";\nimport { debounce } from \"./utility\";\nimport shallowEqual from \"./shallowEqual\";\nvar WATCH_CONTAINER_ELEMENT_TOP_COORDINATE_INTERVAL = 500;\nvar WATCH_CONTAINER_ELEMENT_TOP_COORDINATE_MAX_DURATION = 3000;\nvar SCROLLABLE_CONTAINER_RESIZE_DEBOUNCE_INTERVAL = 250;\nvar WAIT_FOR_USER_TO_STOP_SCROLLING_TIMEOUT = 100;\n\nvar VirtualScroller =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param  {function} getContainerElement — Returns the container DOM `Element`.\n   * @param  {any[]} items — The list of items.\n   * @param  {Object} [options] — See README.md.\n   * @return {VirtualScroller}\n   */\n  function VirtualScroller(getContainerElement, items) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, VirtualScroller);\n\n    _defineProperty(this, \"updateLayout\", function () {\n      return _this.onUpdateShownItemIndexes({\n        reason: \"manual\"\n      });\n    });\n\n    _defineProperty(this, \"onScroll\", function () {\n      return _this.onUpdateShownItemIndexes({\n        reason: \"scroll\"\n      });\n    });\n\n    _defineProperty(this, \"restoreScrollPosition\", function () {\n      var _this$getState = _this.getState(),\n          scrollY = _this$getState.scrollY;\n\n      if (scrollY !== undefined) {\n        _this.scrollTo(0, scrollY);\n      }\n    });\n\n    _defineProperty(this, \"updateScrollPosition\", function () {\n      return _this.getState().scrollY = _this.getScrollY();\n    });\n\n    _defineProperty(this, \"layout\", function () {\n      return _this.updateLayout();\n    });\n\n    _defineProperty(this, \"onResize\", debounce(function (event) {\n      // If `VirtualScroller` has been unmounted\n      // while `setTimeout()` was waiting, then exit.\n      if (!_this.isRendered) {\n        return;\n      }\n\n      var action = _this.shouldUpdateLayoutOnScrollableContainerResize(event);\n\n      if (action === \"UPDATE_LAYOUT\") {\n        // Reset item heights because if scrollable container's width (or height)\n        // has changed, the list width (or height) most likely also has changed,\n        // and also some CSS `@media()` rules might have been added or removed.\n        // Re-render the list entirely.\n        log(\"~ Scrollable container size changed, re-measure item heights. ~\");\n        _this.resized = true;\n\n        _this.setState(_this.getInitialLayoutState());\n      } else if (action === \"UPDATE_INDEXES\") {\n        // No need to perform a complete re-layout.\n        // Just update shown item indexes.\n        _this.onUpdateShownItemIndexes({\n          reason: \"resize\"\n        });\n      }\n    }, SCROLLABLE_CONTAINER_RESIZE_DEBOUNCE_INTERVAL));\n\n    _defineProperty(this, \"willUpdateState\", function (newState, prevState) {\n      // Ignore setting initial state.\n      if (!prevState) {\n        return;\n      }\n\n      if (_this.preserveScrollPositionOnPrependItems) {\n        _this.preserveScrollPositionOnPrependItems = undefined;\n        var previousItems = prevState.items;\n        var newItems = newState.items;\n\n        var _getItemsDiff = getItemsDiff(previousItems, newItems),\n            prependedItemsCount = _getItemsDiff.prependedItemsCount; // Since some items were prepended, scroll Y position\n        // should be restored after rendering those new items.\n\n\n        _this.captureScroll(previousItems, newItems, prependedItemsCount);\n      }\n    });\n\n    _defineProperty(this, \"didUpdateState\", function (prevState) {\n      var newState = _this.getState();\n\n      if (_this.onStateChange) {\n        if (!shallowEqual(newState, prevState)) {\n          _this.onStateChange(newState, prevState);\n        }\n      } // Ignore setting initial state.\n\n\n      if (!prevState) {\n        return;\n      }\n\n      if (!_this.isRendered) {\n        return;\n      }\n\n      log(\"~ Rendered ~\"); // If new items are shown (or older items are hidden).\n\n      if (newState.firstShownItemIndex !== prevState.firstShownItemIndex || newState.lastShownItemIndex !== prevState.lastShownItemIndex || newState.items !== prevState.items) {\n        // // If some items' height changed then maybe adjust scroll position accordingly.\n        // const prevItemHeights = this.getState().itemHeights.slice()\n        _this.onRendered(); // let i = firstShownItemIndex\n        // while (i <= lastShownItemIndex) {\n        // \tthis.adjustScrollPositionIfNeeded(i, prevItemHeights[i])\n        // \ti++\n        // }\n\n      }\n\n      var previousItems = prevState.items;\n      var newItems = newState.items;\n\n      if (newItems !== previousItems) {\n        var _getItemsDiff2 = getItemsDiff(previousItems, newItems),\n            prependedItemsCount = _getItemsDiff2.prependedItemsCount,\n            appendedItemsCount = _getItemsDiff2.appendedItemsCount;\n\n        var isIncrementalUpdate = prependedItemsCount > 0 || appendedItemsCount > 0;\n\n        if (isIncrementalUpdate) {\n          if (prependedItemsCount > 0) {\n            _this.itemHeights.onPrepend(prependedItemsCount);\n\n            if (_this.firstSeenItemIndex !== undefined) {\n              _this.firstSeenItemIndex += prependedItemsCount;\n              _this.lastSeenItemIndex += prependedItemsCount;\n            }\n          }\n        } else {\n          _this.itemHeights.initialize();\n\n          _this.firstSeenItemIndex = undefined;\n          _this.lastSeenItemIndex = undefined;\n        }\n\n        _this.updateSeenItemIndexes(); // Stop \"multi-render layout\" if it's in progress.\n\n\n        if (_this.multiRenderLayout) {\n          _this.stopMultiRenderLayout();\n        }\n\n        return _this.onUpdateShownItemIndexes({\n          reason: \"update items\",\n          force: true\n        });\n      }\n\n      if (_this.resized) {\n        _this.resized = undefined;\n        log(\"~ Rendered (resize) ~\"); // Stop \"multi-render layout\" if it's in progress.\n\n        if (_this.multiRenderLayout) {\n          _this.stopMultiRenderLayout();\n        } // Reset item heights because if scrollable container's width (or height)\n        // has changed, the list width (or height) most likely also has changed,\n        // and also some CSS `@media()` rules might have been added or removed.\n        // Re-render the list entirely.\n\n\n        return _this.onUpdateShownItemIndexes({\n          reason: \"resize\"\n        });\n      }\n\n      if (_this.multiRenderLayout) {\n        return _this.onMultiRenderLayoutRendered();\n      }\n    });\n\n    _defineProperty(this, \"updateShownItemIndexes\", function () {\n      // Find the items which are displayed in the viewport.\n      var _this$getShownItemInd = _this.getShownItemIndexes(),\n          firstShownItemIndex = _this$getShownItemInd.firstShownItemIndex,\n          lastShownItemIndex = _this$getShownItemInd.lastShownItemIndex,\n          redoLayoutAfterRender = _this$getShownItemInd.redoLayoutAfterRender; // Measure \"before\" items height.\n\n\n      var beforeItemsHeight = _this.getBeforeItemsHeight(firstShownItemIndex, lastShownItemIndex); // Measure \"after\" items height.\n\n\n      var afterItemsHeight = _this.getAfterItemsHeight(firstShownItemIndex, lastShownItemIndex); // Update the heights of items to be hidden on next render.\n      // For example, a user could click a \"Show more\" button,\n      // or an \"Expand YouTube video\" button, which would result\n      // in the list item height changing and `this.itemHeights[i]`\n      // being stale, so it's updated here when hiding the item.\n\n\n      _this.updateWillBeHiddenItemHeightsAndState(firstShownItemIndex, lastShownItemIndex); // Debugging.\n\n\n      log(\"~ Layout results \" + (_this.bypass ? \"(bypass) \" : \"\") + \"~\");\n      log(\"First shown item index\", firstShownItemIndex);\n      log(\"Last shown item index\", lastShownItemIndex);\n      log(\"Before items height\", beforeItemsHeight);\n      log(\"After items height (actual or estimated)\", afterItemsHeight);\n      log(\"Average item height (calculated on previous render)\", _this.itemHeights.getAverage());\n\n      if (isDebug()) {\n        log(\"Item heights\", _this.getState().itemHeights.slice());\n        log(\"Item states\", _this.getState().itemStates.slice());\n      }\n\n      if (redoLayoutAfterRender) {\n        log(\"Schedule a re-layout after the upcoming rerender\");\n        _this.redoLayoutAfterRender = true;\n      } // The page could be scrolled up, to any scroll position,\n      // for example, via \"Home\" key, resulting in `lastShownItemIndex`\n      // being less than `this.firstSeenItemIndex`.\n      // `firstShownItemIndex` can't be greater than `this.lastSeenItemIndex`\n      // in the current design of this library, but just in case.\n\n\n      if (_this.firstSeenItemIndex !== undefined) {\n        if (firstShownItemIndex > _this.lastSeenItemIndex + 1 || lastShownItemIndex < _this.firstSeenItemIndex - 1) {\n          // Reset \"seen\" indexes.\n          _this.firstSeenItemIndex = undefined;\n          _this.lastSeenItemIndex = undefined;\n        }\n      } // Optionally preload items to be rendered.\n\n\n      _this.onBeforeShowItems(_this.getState().items, firstShownItemIndex, lastShownItemIndex, _this.firstSeenItemIndex, _this.lastSeenItemIndex); // Render.\n\n\n      _this.setState({\n        firstShownItemIndex: firstShownItemIndex,\n        lastShownItemIndex: lastShownItemIndex,\n        beforeItemsHeight: beforeItemsHeight,\n        afterItemsHeight: afterItemsHeight // // Average item height is stored in state to differentiate between\n        // // the initial state and \"anything has been measured already\" state.\n        // averageItemHeight: this.itemHeights.getAverage()\n\n      });\n    });\n\n    _defineProperty(this, \"updateShownItemIndexesRecursive\", function () {\n      _this.multiRenderLayout = true;\n\n      _this.updateShownItemIndexes();\n    });\n\n    _defineProperty(this, \"restoreScroll\", function () {\n      var _this$restoreScrollAf = _this.restoreScrollAfterPrepend,\n          index = _this$restoreScrollAf.index,\n          visibleAreaTop = _this$restoreScrollAf.visibleAreaTop;\n      _this.restoreScrollAfterPrepend = undefined;\n\n      var newVisibleAreaTop = _this.getItemElement(index).getBoundingClientRect().top;\n\n      var scrollByY = newVisibleAreaTop - visibleAreaTop;\n\n      if (scrollByY !== 0) {\n        log(\"Restore scroll position: scroll by\", scrollByY);\n\n        _this.scrollTo(0, _this.getScrollY() + scrollByY);\n      }\n    });\n\n    _defineProperty(this, \"onUpdateShownItemIndexes\", function (_ref) {\n      var reason = _ref.reason,\n          force = _ref.force;\n\n      // Not implementing the \"delayed\" layout feature for now.\n      // if (this.delayLayout({ reason, force })) {\n      // \treturn\n      // }\n      //\n      // If there're no items then no need to calculate the layout:\n      // if empty `items` have been set on `state` then it has rendered nothing.\n      if (_this.getItemsCount() === 0) {\n        return;\n      } // If a re-layout is already scheduled then it will happen anyway\n      // for the same `state` so there's no need to start another one.\n\n\n      if (_this.multiRenderLayout) {\n        return;\n      } // Prefer not re-rendering the list as the user's scrolling.\n      // Instead, prefer delaying such re-renders until the user stops scrolling.\n      //\n      // If the user has scrolled then it means that they haven't\n      // stopped scrolling so cancel the timeout.\n      // Otherwise, a layout happens so no need for the deferred one\n      // so cancel the timeout anyway.\n\n\n      clearTimeout(_this.onUserStopsScrollingTimeout); //\n\n      if (reason === \"scroll\") {\n        // See whether rendering new previous/next items is required right now\n        // or it can be deferred until the user stops scrolling for better perceived performance.\n        // const top = this.getTopOffset()\n        // const height = this.scrollableContainer.getHeight()\n        // const bottom = top + height\n        // const { top: visibleAreaTop, bottom: visibleAreaBottom } = this.getVisibleAreaBounds()\n        // const renderedItemsTop = top + this.getState().beforeItemsHeight\n        // const renderedItemsBottom = top + height - this.getState().afterItemsHeight\n        // const forceRender = (visibleAreaTop < renderedItemsTop && this.getState().firstShownItemIndex > 0) ||\n        // \t(visibleAreaBottom > renderedItemsBottom && this.getState().lastShownItemIndex < this.getItemsCount() - 1)\n        var forceRender = // If the items have been rendered at least one\n        _this.latestLayoutVisibleAreaTopAfterIncludingMargin !== undefined && // If the user has scrolled up past the extra \"margin\"\n        _this.getScrollY() < _this.latestLayoutVisibleAreaTopAfterIncludingMargin && // and if there're any previous non-rendered items to render.\n        _this.getState().firstShownItemIndex > 0 || // If the items have been rendered at least one\n        _this.latestLayoutVisibleAreaBottomAfterIncludingMargin !== undefined && // If the user has scrolled down past the extra \"margin\"\n        _this.getScrollY() + _this.scrollableContainer.getHeight() > _this.latestLayoutVisibleAreaBottomAfterIncludingMargin && // and if there're any next non-rendered items to render.\n        _this.getState().lastShownItemIndex < _this.getItemsCount() - 1;\n\n        if (forceRender) {\n          log(\"The user has scrolled far enough: force re-render\");\n        } else {\n          log(\"The user hasn't scrolled too much: delay re-render\");\n        } // \"scroll\" events are usually dispatched every 16 milliseconds\n        // for the 60fps refresh rate, so waiting for 100 milliseconds\n        // is about 6 frames of inactivity which would definitely mean\n        // that either the user's no longer scrolling or the browser's\n        // stuttering (skipping frames due to high load) anyway.\n\n\n        if (!forceRender) {\n          return _this.onUserStopsScrollingTimeout = setTimeout(_this.onUserStoppedScrolling, WAIT_FOR_USER_TO_STOP_SCROLLING_TIMEOUT);\n        }\n      } // // A minor optimization. Just because I can.\n      // this.listCoordinatesCached = listCoordinates\n      // Re-render the list.\n\n\n      log(\"~ Update layout (on \".concat(reason, \") ~\"));\n\n      _this.updateShownItemIndexesRecursive();\n    });\n\n    _defineProperty(this, \"onUserStoppedScrolling\", function () {\n      if (_this.isRendered) {\n        // Re-render the list.\n        _this.updateLayout(\"stopped scrolling\");\n      }\n    });\n\n    var getState = options.getState,\n        setState = options.setState,\n        onStateChange = options.onStateChange,\n        customState = options.customState,\n        preserveScrollPositionAtBottomOnMount = options.preserveScrollPositionAtBottomOnMount,\n        shouldUpdateLayoutOnWindowResize = options.shouldUpdateLayoutOnWindowResize,\n        measureItemsBatchSize = options.measureItemsBatchSize,\n        getScrollableContainer = options.getScrollableContainer,\n        tbody = options.tbody;\n    var bypass = options.bypass,\n        estimatedItemHeight = options.estimatedItemHeight,\n        onItemInitialRender = options.onItemInitialRender,\n        onItemFirstRender = options.onItemFirstRender,\n        scrollableContainer = options.scrollableContainer,\n        preserveScrollPositionOfTheBottomOfTheListOnMount = options.preserveScrollPositionOfTheBottomOfTheListOnMount,\n        state = options.state;\n    log(\"~ Initialize ~\"); // If `state` is passed then use `items` from `state`\n    // instead of the `items` argument.\n\n    if (state) {\n      items = state.items;\n    } // `getScrollableContainer` option is deprecated.\n    // Use `scrollableContainer` instead.\n\n\n    if (!scrollableContainer && getScrollableContainer) {\n      scrollableContainer = getScrollableContainer();\n    }\n\n    if (scrollableContainer) {\n      this.scrollableContainer = new ScrollableContainer(scrollableContainer);\n    } else if (typeof window !== \"undefined\") {\n      this.scrollableContainer = new ScrollableWindowContainer();\n    } // if (margin === undefined) {\n    // \t// Renders items which are outside of the screen by this \"margin\".\n    // \t// Is the screen height by default: seems to be the optimal value\n    // \t// for \"Page Up\" / \"Page Down\" navigation and optimized mouse wheel scrolling.\n    // \tmargin = this.scrollableContainer ? this.scrollableContainer.getHeight() : 0\n    // }\n    // Work around `<tbody/>` not being able to have `padding`.\n    // https://gitlab.com/catamphetamine/virtual-scroller/-/issues/1\n\n\n    if (tbody) {\n      log(\"~ <tbody/> detected ~\");\n      this.tbody = true;\n\n      if (!supportsTbody()) {\n        log(\"~ <tbody/> not supported ~\");\n        reportTbodyIssue();\n        bypass = true;\n      }\n    }\n\n    if (bypass) {\n      log('~ \"bypass\" mode ~');\n    } // In `bypass` mode, `VirtualScroller` doesn't wait\n    // for the user to scroll down to render all items:\n    // instead, it renders all items right away, as if\n    // the list is rendered without using `VirtualScroller`.\n    // It was added just to measure how much is the\n    // performance difference between using a `VirtualScroller`\n    // and not using a `VirtualScroller`.\n    // It turned out that unmounting large React component trees\n    // is a very long process, so `VirtualScroller` does seem to\n    // make sense when used in a React application.\n\n\n    this.bypass = bypass; // this.bypassBatchSize = bypassBatchSize || 10\n\n    this.initialItems = items; // this.margin = margin\n\n    this.estimatedItemHeight = estimatedItemHeight; // this.getItemState = getItemState\n\n    this.onStateChange = onStateChange;\n    this._shouldUpdateLayoutOnWindowResize = shouldUpdateLayoutOnWindowResize;\n    this.measureItemsBatchSize = measureItemsBatchSize === undefined ? 50 : measureItemsBatchSize;\n\n    if (onItemInitialRender) {\n      this.onItemFirstRender = onItemInitialRender;\n    } // `onItemFirstRender(i)` is deprecated, use `onItemInitialRender(item)` instead.\n    else if (onItemFirstRender) {\n        this.onItemFirstRender = function (item) {\n          console.warn(\"[virtual-scroller] `onItemFirstRender(i)` is deprecated, use `onItemInitialRender(item)` instead.\");\n\n          var _this$getState2 = _this.getState(),\n              items = _this$getState2.items;\n\n          var i = items.indexOf(item); // The `item` could also be non-found due to the inconsistency bug:\n          // The reason is that `i` can be non-consistent with the `items`\n          // passed to `<VirtualScroller/>` in React due to `setState()` not being\n          // instanteneous: when new `items` are passed to `<VirtualScroller/>`,\n          // `VirtualScroller.setState({ items })` is called, and if `onItemFirstRender(i)`\n          // is called after the aforementioned `setState()` is called but before it finishes,\n          // `i` would point to an index in \"previous\" `items` while the application\n          // would assume that `i` points to an index in the \"new\" `items`,\n          // resulting in an incorrect item being assumed by the application\n          // or even in an \"array index out of bounds\" error.\n\n          if (i >= 0) {\n            onItemFirstRender(i);\n          }\n        };\n      }\n\n    if (setState) {\n      this.getState = getState;\n\n      this.setState = function (state) {\n        return setState(state, {\n          willUpdateState: _this.willUpdateState,\n          didUpdateState: _this.didUpdateState\n        });\n      };\n    } else {\n      this.getState = function () {\n        return _this.state;\n      };\n\n      this.setState = function (state) {\n        var prevState = _this.getState();\n\n        var newState = _objectSpread({}, prevState, state);\n\n        _this.willUpdateState(newState, prevState);\n\n        _this.state = newState;\n\n        _this.didUpdateState(prevState);\n      };\n    }\n\n    if (state) {\n      log(\"Initial state (passed)\", state);\n    } // Sometimes, when `new VirtualScroller()` instance is created,\n    // `getContainerElement()` might not be ready to return the \"container\" DOM Element yet\n    // (for example, because it's not rendered yet). That's the reason why it's a getter function.\n    // For example, in React, on server side, where there's no \"container\" DOM Element,\n    // it still \"renders\" a list with a predefined amount of items in it by default.\n    // (`initiallyRenderedItemsCount`, or `1`).\n\n\n    this.getContainerElement = getContainerElement; // Remove any accidental text nodes from container (like whitespace).\n    // Also guards against cases when someone accidentally tries\n    // using `VirtualScroller` on a non-empty element.\n\n    if (getContainerElement()) {\n      clearElement(getContainerElement());\n    }\n\n    this.itemHeights = new ItemHeights(this.getContainerElement, this.getState);\n\n    if (this.scrollableContainer) {\n      if (preserveScrollPositionAtBottomOnMount) {\n        console.warn(\"[virtual-scroller] `preserveScrollPositionAtBottomOnMount` option/property has been renamed to `preserveScrollPositionOfTheBottomOfTheListOnMount`\");\n        preserveScrollPositionOfTheBottomOfTheListOnMount = preserveScrollPositionAtBottomOnMount;\n      }\n\n      if (preserveScrollPositionOfTheBottomOfTheListOnMount) {\n        this.preserveScrollPositionOfTheBottomOfTheListOnMount = {\n          scrollableContainerContentHeight: this.scrollableContainer.getContentHeight()\n        };\n      }\n    }\n\n    this.setState(state || this.getInitialState(customState));\n    log(\"Items count\", items.length);\n\n    if (estimatedItemHeight) {\n      log(\"Estimated item height\", estimatedItemHeight);\n    }\n  }\n  /**\n   * Returns the initial state of the `VirtualScroller`.\n   * @param  {object} [customState] — Any additional \"custom\" state may be stored in `VirtualScroller`'s state. For example, React implementation stores item \"refs\" as \"custom\" state.\n   * @return {object}\n   */\n\n\n  _createClass(VirtualScroller, [{\n    key: \"getInitialState\",\n    value: function getInitialState(customState) {\n      var itemsCount = this.initialItems.length;\n\n      var state = _objectSpread({}, customState, this.getInitialLayoutState(), {\n        items: this.initialItems,\n        itemStates: new Array(itemsCount)\n      });\n\n      log(\"Initial state (autogenerated)\", state);\n      log(\"First shown item index\", state.firstShownItemIndex);\n      log(\"Last shown item index\", state.lastShownItemIndex);\n      return state;\n    }\n  }, {\n    key: \"getInitialLayoutState\",\n    value: function getInitialLayoutState() {\n      var firstShownItemIndex;\n      var lastShownItemIndex;\n      var items = this.initialItems;\n      var itemsCount = items.length; // If there're no items then `firstShownItemIndex` stays `undefined`.\n\n      if (itemsCount > 0) {\n        firstShownItemIndex = 0;\n        lastShownItemIndex = this.getLastShownItemIndex(firstShownItemIndex, itemsCount);\n      }\n\n      if (this.preserveScrollPositionOfTheBottomOfTheListOnMount) {\n        firstShownItemIndex = 0;\n        lastShownItemIndex = itemsCount - 1;\n      } // Optionally preload items to be rendered.\n\n\n      this.onBeforeShowItems(items, firstShownItemIndex, lastShownItemIndex, this.firstSeenItemIndex, this.lastSeenItemIndex);\n      return {\n        itemHeights: new Array(itemsCount),\n        itemSpacing: undefined,\n        beforeItemsHeight: 0,\n        afterItemsHeight: 0,\n        firstShownItemIndex: firstShownItemIndex,\n        lastShownItemIndex: lastShownItemIndex,\n        scrollY: undefined\n      };\n    }\n    /**\n     * Returns estimated list item height.\n     * (depends on which items have been previously rendered and measured).\n     * @return {number}\n     */\n\n  }, {\n    key: \"getEstimatedItemHeight\",\n    value: function getEstimatedItemHeight() {\n      return this.itemHeights && this.itemHeights.getAverage() || this.estimatedItemHeight || 0;\n    }\n  }, {\n    key: \"getItemSpacing\",\n    value: function getItemSpacing() {\n      return this.getState() && this.getState().itemSpacing || 0;\n    }\n  }, {\n    key: \"getEstimatedItemsCount\",\n    value: function getEstimatedItemsCount(height) {\n      if (this.getEstimatedItemHeight()) {\n        return Math.ceil((height + this.getItemSpacing()) / (this.getEstimatedItemHeight() + this.getItemSpacing()));\n      } else {\n        return 1;\n      }\n    }\n  }, {\n    key: \"getEstimatedItemsCountOnScreen\",\n    value: function getEstimatedItemsCountOnScreen() {\n      if (this.scrollableContainer) {\n        return this.getEstimatedItemsCount(this.getMargin() * 2 + this.scrollableContainer.getHeight());\n      } else {\n        return 1;\n      }\n    }\n  }, {\n    key: \"getLastShownItemIndex\",\n    value: function getLastShownItemIndex(firstShownItemIndex, itemsCount) {\n      if (this.bypass) {\n        return itemsCount - 1;\n      }\n\n      return Math.min(firstShownItemIndex + (this.getEstimatedItemsCountOnScreen() - 1), itemsCount - 1);\n    }\n  }, {\n    key: \"getItemsCount\",\n    value: function getItemsCount() {\n      return this.getState().items.length;\n    }\n  }, {\n    key: \"getMargin\",\n    value: function getMargin() {\n      // `VirtualScroller` also items that are outside of the screen\n      // by the amount of this \"render ahead margin\" (both on top and bottom).\n      // The default \"render ahead margin\" is equal to the screen height:\n      // this seems to be the optimal value for \"Page Up\" / \"Page Down\" navigation\n      // and optimized mouse wheel scrolling (a user is unlikely to continuously\n      // scroll past the height of a screen, and when they stop scrolling,\n      // the list is re-rendered).\n      var renderAheadMarginRatio = 1; // in scrollable container heights.\n\n      return this.scrollableContainer.getHeight() * renderAheadMarginRatio;\n    }\n  }, {\n    key: \"onBeforeShowItems\",\n    value: function onBeforeShowItems(items, firstShownItemIndex, lastShownItemIndex, firstSeenItemIndex, lastSeenItemIndex) {\n      var onItemFirstRender = this.onItemFirstRender;\n\n      if (onItemFirstRender) {\n        if (firstSeenItemIndex === undefined) {\n          var i = firstShownItemIndex;\n\n          while (i <= lastShownItemIndex) {\n            onItemFirstRender(items[i]);\n            i++;\n          }\n        } else {\n          // The library is designed in such a way that\n          // `[firstShownItemIndex, lastShownItemIndex]` always intersects\n          // (or touches or contains or is contained by)\n          // `[firstSeenItemIndex, lastSeenItemIndex]`.\n          if (firstShownItemIndex < firstSeenItemIndex) {\n            var fromIndex = firstShownItemIndex;\n            var toIndex = Math.min(lastShownItemIndex, firstSeenItemIndex - 1);\n            var _i = fromIndex;\n\n            while (_i <= toIndex) {\n              onItemFirstRender(items[_i]);\n              _i++;\n            }\n          }\n\n          if (lastShownItemIndex > lastSeenItemIndex) {\n            var _toIndex = lastShownItemIndex;\n\n            var _fromIndex = Math.max(firstShownItemIndex, lastSeenItemIndex + 1);\n\n            var _i2 = _fromIndex;\n\n            while (_i2 <= _toIndex) {\n              onItemFirstRender(items[_i2]);\n              _i2++;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"updateSeenItemIndexes\",\n    value: function updateSeenItemIndexes() {\n      var firstSeenItemIndex = this.firstSeenItemIndex,\n          lastSeenItemIndex = this.lastSeenItemIndex;\n\n      var _this$getState3 = this.getState(),\n          firstShownItemIndex = _this$getState3.firstShownItemIndex,\n          lastShownItemIndex = _this$getState3.lastShownItemIndex;\n\n      if (firstSeenItemIndex === undefined) {\n        firstSeenItemIndex = firstShownItemIndex;\n        lastSeenItemIndex = lastShownItemIndex;\n      } else {\n        // The library is designed in such a way that\n        // `[firstShownItemIndex, lastShownItemIndex]` always intersects\n        // (or touches or contains or is contained by)\n        // `[firstSeenItemIndex, lastSeenItemIndex]`.\n        if (firstShownItemIndex < firstSeenItemIndex) {\n          firstSeenItemIndex = firstShownItemIndex;\n        }\n\n        if (lastShownItemIndex > lastSeenItemIndex) {\n          lastSeenItemIndex = lastShownItemIndex;\n        }\n      }\n\n      this.firstSeenItemIndex = firstSeenItemIndex;\n      this.lastSeenItemIndex = lastSeenItemIndex;\n    }\n  }, {\n    key: \"onMount\",\n    value: function onMount() {\n      console.warn(\"[virtual-scroller] `.onMount()` instance method name is deprecated, use `.listen()` instance method name instead.\");\n      this.listen();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      console.warn(\"[virtual-scroller] `.render()` instance method name is deprecated, use `.listen()` instance method name instead.\");\n      this.listen();\n    }\n    /**\n     * Should be invoked after a \"container\" DOM Element is mounted (inserted into the DOM tree).\n     */\n\n  }, {\n    key: \"listen\",\n    value: function listen() {\n      if (this.isRendered === false) {\n        throw new Error(\"[virtual-scroller] Can't restart a `VirtualScroller` after it has been stopped\");\n      }\n\n      log(\"~ Rendered (initial) ~\"); // `this.isRendered = true` should be the first statement in this function,\n      // otherwise `DOMVirtualScroller` would enter an infinite re-render loop.\n\n      this.isRendered = true;\n      this.onRendered();\n      this.scrollableContainerWidth = this.scrollableContainer.getWidth();\n      this.scrollableContainerHeight = this.scrollableContainer.getHeight();\n      this.restoreScrollPosition();\n      this.updateScrollPosition();\n      this.removeScrollPositionListener = this.scrollableContainer.addScrollListener(this.updateScrollPosition);\n\n      if (!this.bypass) {\n        this.removeScrollListener = this.scrollableContainer.addScrollListener(this.onScroll);\n        this.scrollableContainerUnlistenResize = this.scrollableContainer.onResize(this.onResize);\n      } // Work around `<tbody/>` not being able to have `padding`.\n      // https://gitlab.com/catamphetamine/virtual-scroller/-/issues/1\n\n\n      if (this.tbody) {\n        addTbodyStyles(this.getContainerElement());\n      }\n\n      if (this.preserveScrollPositionOfTheBottomOfTheListOnMount) {\n        // In this case, all items are shown, so there's no need to call\n        // `this.onUpdateShownItemIndexes()` after the initial render.\n        this.scrollTo(0, this.getScrollY() + (this.scrollableContainer.getHeight() - this.preserveScrollPositionOfTheBottomOfTheListOnMount.scrollableContainerContentHeight));\n      } else {\n        this.onUpdateShownItemIndexes({\n          reason: \"mount\"\n        });\n      }\n    }\n  }, {\n    key: \"onRendered\",\n    value: function onRendered() {\n      // Update seen item heights.\n      this.updateItemHeights();\n\n      if (this.tbody) {\n        this.updateTbodyPadding();\n      }\n    }\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(scrollX, scrollY) {\n      this.scrollableContainer.scrollTo(scrollX, scrollY);\n    }\n  }, {\n    key: \"getScrollY\",\n    value: function getScrollY() {\n      return this.scrollableContainer.getScrollY();\n    }\n    /**\n     * Returns visible area coordinates relative to the scrollable container.\n     * @return {object} `{ top: number, bottom: number }`\n     */\n\n  }, {\n    key: \"getVisibleAreaBounds\",\n    value: function getVisibleAreaBounds() {\n      var scrollY = this.getScrollY();\n      return {\n        // The first pixel of the screen.\n        top: scrollY,\n        // The pixel after the last pixel of the screen.\n        bottom: scrollY + this.scrollableContainer.getHeight()\n      };\n    }\n    /**\n     * Returns list height.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return this.getContainerElement().getBoundingClientRect().height;\n    }\n    /**\n     * Returns list top coordinate relative to the scrollable container.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getTopOffset\",\n    value: function getTopOffset() {\n      return this.scrollableContainer.getTopOffset(this.getContainerElement());\n    }\n  }, {\n    key: \"shouldUpdateLayoutOnScrollableContainerResize\",\n    value: function shouldUpdateLayoutOnScrollableContainerResize(event) {\n      if (event && event.target === window) {\n        // By default, `VirtualScroller` always performs a re-layout\n        // on window `resize` event. But browsers (Chrome, Firefox)\n        // [trigger](https://developer.mozilla.org/en-US/docs/Web/API/Window/fullScreen#Notes)\n        // window `resize` event also when a user switches into fullscreen mode:\n        // for example, when a user is watching a video and double-clicks on it\n        // to maximize it. And also when the user goes out of the fullscreen mode.\n        // Each such fullscreen mode entering/exiting will trigger window `resize`\n        // event that will it turn trigger a re-layout of `VirtualScroller`,\n        // resulting in bad user experience. To prevent that, such cases are filtered out.\n        // Some other workaround:\n        // https://stackoverflow.com/questions/23770449/embedded-youtube-video-fullscreen-or-causing-resize\n        if (document.fullscreenElement && this.getContainerElement().contains(document.fullscreenElement)) {\n          return false;\n        }\n\n        if (this._shouldUpdateLayoutOnWindowResize) {\n          if (!this._shouldUpdateLayoutOnWindowResize(event)) {\n            return false;\n          }\n        }\n      }\n\n      var prevScrollableContainerWidth = this.scrollableContainerWidth;\n      var prevScrollableContainerHeight = this.scrollableContainerHeight;\n      this.scrollableContainerWidth = this.scrollableContainer.getWidth();\n      this.scrollableContainerHeight = this.scrollableContainer.getHeight();\n\n      if (this.scrollableContainerWidth === prevScrollableContainerWidth) {\n        if (this.scrollableContainerHeight === prevScrollableContainerHeight) {\n          return false;\n        } else {\n          // Scrollable container height has changed,\n          // so recalculate shown item indexes.\n          return \"UPDATE_INDEXES\";\n        }\n      } else {\n        return \"UPDATE_LAYOUT\";\n      }\n    }\n    /**\n     * On scrollable container resize.\n     * @param  {Event} [event] — DOM resize event.\n     */\n\n  }, {\n    key: \"onUnmount\",\n    value: function onUnmount() {\n      console.warn(\"[virtual-scroller] `.onUnmount()` instance method name is deprecated, use `.stop()` instance method name instead.\");\n      this.stop();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      console.warn(\"[virtual-scroller] `.destroy()` instance method name is deprecated, use `.stop()` instance method name instead.\");\n      this.stop();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.isRendered = false;\n      this.removeScrollPositionListener();\n\n      if (!this.bypass) {\n        this.removeScrollListener();\n        this.scrollableContainerUnlistenResize(); // this.untrackScrollableContainer\n\n        clearTimeout(this.onUserStopsScrollingTimeout);\n        clearTimeout(this.watchContainerElementCoordinatesTimer);\n      }\n    }\n    /**\n     * Should be called right before `state` is updated.\n     * Is used to capture scroll position in order to restore it after the update.\n     * @param  {object} prevState\n     * @param  {object} newState\n     */\n\n  }, {\n    key: \"updateTbodyPadding\",\n\n    /**\n     * Is part of a workaround for `<tbody/>` not being able to have `padding`.\n     * https://gitlab.com/catamphetamine/virtual-scroller/-/issues/1\n     * CSS variables aren't supported in Internet Explorer.\n     */\n    value: function updateTbodyPadding() {\n      var _this$getState4 = this.getState(),\n          beforeItemsHeight = _this$getState4.beforeItemsHeight,\n          afterItemsHeight = _this$getState4.afterItemsHeight;\n\n      setTbodyPadding(this.getContainerElement(), beforeItemsHeight, afterItemsHeight);\n    }\n  }, {\n    key: \"updateItemHeights\",\n    value: function updateItemHeights() {\n      var _this$getState5 = this.getState(),\n          fromIndex = _this$getState5.firstShownItemIndex,\n          toIndex = _this$getState5.lastShownItemIndex;\n\n      var _this$getState6 = this.getState(),\n          firstShownItemIndex = _this$getState6.firstShownItemIndex;\n\n      if (fromIndex !== undefined) {\n        log(\"~ Measure item heights ~\");\n        this.itemHeights.update(fromIndex, toIndex, firstShownItemIndex);\n\n        if (isDebug()) {\n          log(\"Item heights\", this.getState().itemHeights.slice());\n        }\n      }\n    }\n  }, {\n    key: \"updateItemHeight\",\n    value: function updateItemHeight(i) {\n      var _this$getState7 = this.getState(),\n          firstShownItemIndex = _this$getState7.firstShownItemIndex;\n\n      this.itemHeights.updateItemHeight(i, firstShownItemIndex);\n    }\n  }, {\n    key: \"onItemStateChange\",\n    value: function onItemStateChange(i, itemState) {\n      if (isDebug()) {\n        log(\"~ Item state changed ~\");\n        log(\"Item\", i);\n        log(\"Previous state\" + \"\\n\" + JSON.stringify(this.getState().itemStates[i], null, 2));\n        log(\"New state\" + \"\\n\" + JSON.stringify(itemState, null, 2));\n      }\n\n      this.getState().itemStates[i] = itemState;\n    }\n  }, {\n    key: \"onItemHeightChange\",\n    value: function onItemHeightChange(i) {\n      var _this$getState8 = this.getState(),\n          itemHeights = _this$getState8.itemHeights;\n\n      var previousHeight = itemHeights[i];\n      this.updateItemHeight(i);\n      var newHeight = itemHeights[i];\n\n      if (previousHeight !== newHeight) {\n        log(\"~ Item height changed ~\");\n        log(\"Item\", i);\n        log(\"Previous height\", previousHeight);\n        log(\"New height\", newHeight);\n        this.onUpdateShownItemIndexes({\n          reason: \"item height change\"\n        });\n      }\n    }\n    /**\n     * Returns coordinates of item with index `i` relative to the document.\n     * `top` is the top offset of the item relative to the start of the document.\n     * `bottom` is the top offset of the item's bottom edge relative to the start of the document.\n     * `height` is the item's height.\n     * @param  {number} i\n     * @return {object} coordinates — An object of shape `{ top, bottom, height }`.\n     */\n\n  }, {\n    key: \"getItemCoordinates\",\n    value: function getItemCoordinates(i) {\n      var top = this.getTopOffset();\n      var j = 0;\n\n      while (j < i) {\n        top += this.getState().itemHeights[j];\n        top += this.getItemSpacing();\n        j++;\n      }\n\n      return {\n        top: top,\n        bottom: top + this.getState().itemHeights[i],\n        height: this.getState().itemHeights[j]\n      };\n    } // Finds the items which are displayed in the viewport.\n\n  }, {\n    key: \"getVisibleItemIndexes\",\n    value: function getVisibleItemIndexes(visibleAreaTop, visibleAreaBottom, listTopOffset) {\n      var firstShownItemIndex;\n      var lastShownItemIndex;\n      var itemsHeight = 0;\n      var firstNonMeasuredItemIndex;\n      var redoLayoutAfterRender = false;\n      var i = 0;\n\n      while (i < this.getItemsCount()) {\n        var height = this.itemHeights.get(i); // If an item that hasn't been shown (and measured) yet is encountered\n        // then show such item and then retry after it has been measured.\n\n        if (height === undefined) {\n          log(\"Item index \".concat(i, \" lies within the visible area or its \\\"margins\\\", but its height hasn't been measured yet. Mark the item as \\\"shown\\\", render the list, measure the item's height and redo the layout.\"));\n          firstNonMeasuredItemIndex = i;\n\n          if (firstShownItemIndex === undefined) {\n            firstShownItemIndex = i;\n          }\n\n          var heightLeft = visibleAreaBottom - (listTopOffset + itemsHeight);\n          lastShownItemIndex = Math.min(i + (this.getEstimatedItemsCount(heightLeft) - 1), // Guard against index overflow.\n          this.getItemsCount() - 1);\n          redoLayoutAfterRender = true;\n          break;\n        }\n\n        itemsHeight += height; // If this is the first item visible\n        // then start showing items from it.\n\n        if (firstShownItemIndex === undefined) {\n          if (listTopOffset + itemsHeight > visibleAreaTop) {\n            log(\"First visible item index\", i);\n            firstShownItemIndex = i;\n          }\n        } // Items can have spacing.\n\n\n        if (i < this.getItemsCount() - 1) {\n          itemsHeight += this.getItemSpacing();\n        } // If this item is the last one visible in the viewport then exit.\n\n\n        if (listTopOffset + itemsHeight > visibleAreaBottom) {\n          log(\"Last visible item index\", i); // The list height is estimated until all items have been seen,\n          // so it's possible that even when the list DOM element happens\n          // to be in the viewport in reality the list isn't visible\n          // in which case `firstShownItemIndex` will be `undefined`.\n\n          if (firstShownItemIndex !== undefined) {\n            lastShownItemIndex = i;\n          }\n\n          break;\n        }\n\n        i++;\n      } // If there're no more items then the last item is the last one to show.\n\n\n      if (firstShownItemIndex !== undefined && lastShownItemIndex === undefined) {\n        lastShownItemIndex = this.getItemsCount() - 1;\n        log(\"Last item index (is fully visible)\", lastShownItemIndex);\n      } // If scroll position is scheduled to be restored after render\n      // then the anchor item must be rendered, and all the prepended\n      // items before it, all in a single pass. This way, all the\n      // prepended items could be measured right after the render\n      // and the scroll position can then be immediately restored.\n\n\n      if (this.restoreScrollAfterPrepend) {\n        if (lastShownItemIndex < this.restoreScrollAfterPrepend.index) {\n          lastShownItemIndex = this.restoreScrollAfterPrepend.index;\n        } // `firstShownItemIndex` is always `0` when prepending items.\n        // And `lastShownItemIndex` always covers all prepended items in this case.\n        // None of the prepended items have been rendered before,\n        // so their heights are unknown. The code at the start of this function\n        // did therefore set `redoLayoutAfterRender` to `true`\n        // in order to render just the first prepended item in order to\n        // measure it, and only then make a decision on how many other\n        // prepended items to render. But since we've instructed the code\n        // to show all of the prepended items at once, then no need to\n        // \"redo layout after render\". Additionally, if `redoLayoutAfterRender`\n        // was left `true` then there would be a short the visual \"jitter\"\n        // happening due to scroll position restoration waiting for two\n        // layout cycles instead of one.\n\n\n        redoLayoutAfterRender = false;\n      } // If some items will be rendered in order to measure their height,\n      // and it's not a `preserveScrollPositionOnPrependItems` case,\n      // then limit the amount of such items being measured in a single pass.\n\n\n      if (redoLayoutAfterRender && this.measureItemsBatchSize) {\n        lastShownItemIndex = Math.min(lastShownItemIndex, firstNonMeasuredItemIndex + this.measureItemsBatchSize - 1);\n      }\n\n      return {\n        firstShownItemIndex: firstShownItemIndex,\n        lastShownItemIndex: lastShownItemIndex,\n        redoLayoutAfterRender: redoLayoutAfterRender\n      };\n    }\n  }, {\n    key: \"getOffscreenListShownItemIndexes\",\n    value: function getOffscreenListShownItemIndexes() {\n      return {\n        firstShownItemIndex: 0,\n        lastShownItemIndex: 0,\n        redoLayoutAfterRender: this.itemHeights.get(0) === undefined\n      };\n    }\n  }, {\n    key: \"getItemIndexes\",\n    value: function getItemIndexes(visibleAreaTop, visibleAreaBottom, listTopOffset, listHeight) {\n      var isVisible = listTopOffset + listHeight > visibleAreaTop && listTopOffset < visibleAreaBottom;\n\n      if (!isVisible) {\n        log(\"Off-screen\");\n        return;\n      } // Find the items which are displayed in the viewport.\n\n\n      var indexes = this.getVisibleItemIndexes(visibleAreaTop, visibleAreaBottom, listTopOffset); // The list height is estimated until all items have been seen,\n      // so it's possible that even when the list DOM element happens\n      // to be in the viewport, in reality the list isn't visible\n      // in which case `firstShownItemIndex` will be `undefined`.\n\n      if (indexes.firstShownItemIndex === undefined) {\n        log(\"Off-screen\");\n        return;\n      }\n\n      return indexes;\n    }\n    /**\n     * Measures \"before\" items height.\n     * @param  {number} firstShownItemIndex — New first shown item index.\n     * @param  {number} lastShownItemIndex — New last shown item index.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getBeforeItemsHeight\",\n    value: function getBeforeItemsHeight(firstShownItemIndex, lastShownItemIndex) {\n      var beforeItemsHeight = 0; // Add all \"before\" items height.\n\n      var i = 0;\n\n      while (i < firstShownItemIndex) {\n        beforeItemsHeight += this.itemHeights.get(i) || this.itemHeights.getAverage();\n        beforeItemsHeight += this.getItemSpacing();\n        i++;\n      }\n\n      return beforeItemsHeight;\n    }\n    /**\n     * Measures \"after\" items height.\n     * @param  {number} firstShownItemIndex — New first shown item index.\n     * @param  {number} lastShownItemIndex — New last shown item index.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getAfterItemsHeight\",\n    value: function getAfterItemsHeight(firstShownItemIndex, lastShownItemIndex) {\n      var afterItemsHeight = 0;\n      var i = lastShownItemIndex + 1; // Add all \"after\" items height.\n\n      while (i < this.getItemsCount()) {\n        afterItemsHeight += this.getItemSpacing();\n        afterItemsHeight += this.itemHeights.get(i) || this.itemHeights.getAverage();\n        i++;\n      }\n\n      return afterItemsHeight;\n    }\n    /**\n     * Updates the heights of items to be hidden on next render.\n     * For example, a user could click a \"Show more\" button,\n     * or an \"Expand YouTube video\" button, which would result\n     * in the list item height changing and `this.itemHeights[i]`\n     * being stale, so it's updated here when hiding the item.\n     */\n\n  }, {\n    key: \"updateWillBeHiddenItemHeightsAndState\",\n    value: function updateWillBeHiddenItemHeightsAndState(firstShownItemIndex, lastShownItemIndex) {\n      var i = this.getState().firstShownItemIndex;\n\n      while (i <= this.getState().lastShownItemIndex) {\n        if (i >= firstShownItemIndex && i <= lastShownItemIndex) {// The item's still visible.\n        } else {\n          // Update item's height before hiding it\n          // because the height of the item may have changed\n          // while it was visible.\n          this.updateItemHeight(i); // // Update item's state because it's about to be hidden.\n          // if (this.getItemState) {\n          // \tthis.getState().itemStates[i] = this.getItemState(\n          // \t\tthis.getState().items[i],\n          // \t\ti,\n          // \t\tthis.getState().items\n          // \t)\n          // }\n        }\n\n        i++;\n      }\n    } // `VirtualScroller` calls `getShownItemIndexes()` on mount\n    // but if the page styles are applied after `VirtualScroller` mounts\n    // (for example, if styles are applied via javascript, like Webpack does)\n    // then the list might not render correctly and will only show the first item.\n    // The reason for that would be that calling `.getBoundingClientRect()`\n    // on the list container element on mount returned \"incorrect\" `top` position\n    // because the styles haven't been applied yet.\n    // For example, consider a page:\n    // <div class=\"page\">\n    //   <nav class=\"sidebar\">...</nav>\n    //   <main>...</main>\n    // </div>\n    // The sidebar is styled as `position: fixed`, but until\n    // the page styles have been applied it's gonna be a regular `<div/>`\n    // meaning that `<main/>` will be rendered below the sidebar\n    // and will appear offscreen and so it will only render the first item.\n    // Then, the page styles are loaded and applied and the sidebar\n    // is now `position: fixed` so `<main/>` is now rendered at the top of the page\n    // but `VirtualScroller`'s `.render()` has already been called\n    // and it won't re-render until the user scrolls or the window is resized.\n    // This type of a bug doesn't occur in production, but it can appear\n    // in development mode when using Webpack. The workaround `VirtualScroller`\n    // implements for such cases is calling `.getBoundingClientRect()` on the\n    // list container DOM element periodically (every second) to check if the\n    // `top` coordinate has changed as a result of CSS being applied:\n    // if it has then it recalculates the shown item indexes.\n\n  }, {\n    key: \"watchContainerElementCoordinates\",\n    value: function watchContainerElementCoordinates() {\n      var _this2 = this;\n\n      var startedAt = Date.now();\n\n      var check = function check() {\n        // If `VirtualScroller` has been unmounted\n        // while `setTimeout()` was waiting, then exit.\n        if (!_this2.isRendered) {\n          return;\n        } // Skip comparing `top` coordinate of the list\n        // when this function is called the first time.\n\n\n        if (_this2.topOffset !== undefined) {\n          // Calling `this.getTopOffset()` on an element is about\n          // 0.003 milliseconds on a modern desktop CPU,\n          // so I guess it's fine calling it twice a second.\n          var topOffset = _this2.getTopOffset();\n\n          if (topOffset !== _this2.topOffset) {\n            _this2.onUpdateShownItemIndexes({\n              reason: \"top offset change\"\n            });\n          }\n        } // Compare `top` coordinate of the list twice a second\n        // to find out if it has changed as a result of loading CSS styles.\n        // The total duration of 3 seconds would be enough for any styles to load, I guess.\n        // There could be other cases changing the `top` coordinate\n        // of the list (like collapsing an \"accordeon\" panel above the list\n        // without scrolling the page), but those cases should be handled\n        // by manually calling `.updateLayout()` instance method on `VirtualScroller` instance.\n\n\n        if (Date.now() - startedAt < WATCH_CONTAINER_ELEMENT_TOP_COORDINATE_MAX_DURATION) {\n          _this2.watchContainerElementCoordinatesTimer = setTimeout(check, WATCH_CONTAINER_ELEMENT_TOP_COORDINATE_INTERVAL);\n        }\n      }; // Run the cycle.\n\n\n      check();\n    }\n    /**\n     * Finds the items that are displayed in the viewport.\n     * @return {object} `{ firstShownItemIndex: number, lastShownItemIndex: number, redoLayoutAfterRender: boolean }`\n     */\n\n  }, {\n    key: \"getShownItemIndexes\",\n    value: function getShownItemIndexes() {\n      if (this.bypass) {\n        return {\n          firstShownItemIndex: 0,\n          lastShownItemIndex: this.getItemsCount() - 1\n        }; // This code emulates batch loading in bypass mode.\n        // const { firstShownItemIndex } = this.getState()\n        // let { lastShownItemIndex } = this.getState()\n        // lastShownItemIndex = Math.min(\n        // \tlastShownItemIndex + this.bypassBatchSize,\n        // \tthis.getItemsCount() - 1\n        // )\n        // return {\n        // \tfirstShownItemIndex,\n        // \tlastShownItemIndex,\n        // \t// Redo layout until all items are rendered.\n        // \tredoLayoutAfterRender: lastShownItemIndex < this.getItemsCount() - 1\n        // }\n      } // // A minor optimization. Just because I can.\n      // let topOffset\n      // if (this.topOffsetCached !== undefined) {\n      // \ttopOffset = this.topOffsetCached\n      // \tthis.topOffsetCached = undefined\n      // } else {\n      // \ttopOffset = this.getTopOffset()\n      // }\n\n\n      var topOffset = this.getTopOffset(); // `this.topOffset` is not used for any \"caching\",\n      // it's only used in `this.watchContainerElementCoordinates()` method.\n\n      if (this.topOffset === undefined) {\n        // See the comments for `watchContainerElementCoordinates()` method\n        // for the rationale on why it's here.\n        this.watchContainerElementCoordinates();\n      }\n\n      this.topOffset = topOffset;\n\n      var _this$getVisibleAreaB = this.getVisibleAreaBounds(),\n          visibleAreaTop = _this$getVisibleAreaB.top,\n          visibleAreaBottom = _this$getVisibleAreaB.bottom; // Set screen top and bottom for current layout.\n\n\n      this.latestLayoutVisibleAreaTopAfterIncludingMargin = visibleAreaTop - this.getMargin();\n      this.latestLayoutVisibleAreaBottomAfterIncludingMargin = visibleAreaBottom + this.getMargin(); // For scrollable containers, this function could not only check\n      // the scrollable container visibility here, but also\n      // adjust `visibleAreaTop` and `visibleAreaBottom`\n      // because some parts of the scrollable container\n      // could be off the screen and therefore not actually visible.\n      // That would also involve somehow fixing the \"should rerender on scroll\"\n      // function, because currently it only checks the scrollable container's\n      // `this.getScrollY()` and compares it to the latest `visibleAreaTop` and `visibleAreaBottom`,\n      // so if those \"actual visibility\" adjustments were applied, they would have to\n      // be somehow accounted for in that \"should rerender on scroll\" function.\n      // Overall, I suppose that such \"actual visibility\" feature would be\n      // a very minor optimization and not something I'd deal with.\n      // Find the items that are displayed in the viewport.\n\n      return this.getItemIndexes(visibleAreaTop - this.getMargin(), visibleAreaBottom + this.getMargin(), topOffset, this.getHeight()) || this.getOffscreenListShownItemIndexes();\n    }\n    /**\n     * Updates the \"from\" and \"to\" shown item indexes.\n     * `callback(redoLayoutAfterRender)` is called after it re-renders.\n     * If the list is visible and some of the items being shown are new\n     * and required to be measured first then `redoLayoutAfterRender` is `true`.\n     * If the list is visible and all items being shown have been encountered\n     * (and measured) before then `redoLayoutAfterRender` is `false`.\n     * @param {Function} callback\n     */\n\n  }, {\n    key: \"onMultiRenderLayoutRendered\",\n    value: function onMultiRenderLayoutRendered() {\n      var _this3 = this;\n\n      if (this.redoLayoutAfterRender) {\n        this.redoLayoutAfterRender = undefined; // Recurse in a timeout to prevent React error:\n        // \"Maximum update depth exceeded.\n        //  This can happen when a component repeatedly calls\n        //  setState inside componentWillUpdate or componentDidUpdate.\n        //  React limits the number of nested updates to prevent infinite loops.\"\n\n        return setTimeout(function () {\n          if (_this3.isRendered) {\n            _this3.updateShownItemIndexesRecursive();\n          }\n        }, 0);\n      }\n\n      this.stopMultiRenderLayout();\n    }\n  }, {\n    key: \"stopMultiRenderLayout\",\n    value: function stopMultiRenderLayout() {\n      this.multiRenderLayout = undefined;\n\n      if (!this.redoLayoutAfterRender) {\n        if (this.restoreScrollAfterPrepend) {\n          this.restoreScroll();\n        }\n      }\n    }\n  }, {\n    key: \"captureScroll\",\n    value: function captureScroll(previousItems, nextItems, firstPreviousItemIndex) {\n      // If there were no items in the list\n      // then there's no point in restoring scroll position.\n      if (previousItems.length === 0) {\n        return;\n      }\n\n      if (firstPreviousItemIndex === undefined) {\n        firstPreviousItemIndex = nextItems.indexOf(previousItems[0]);\n      } // If the items update wasn't incremental\n      // then there's no point in restoring scroll position.\n\n\n      if (firstPreviousItemIndex < 0) {\n        return;\n      } // If no items were prepended then no need to restore scroll position.\n\n\n      if (firstPreviousItemIndex === 0) {\n        return;\n      } // The first item DOM Element must be rendered in order to get its top position.\n\n\n      if (this.getState().firstShownItemIndex > 0) {\n        return;\n      } // If the scroll position for these `previousItems` -> `nextItems`\n      // has already been captured then skip.\n      // This could happen when using `<ReactVirtualScroller/>`\n      // because it calls `.captureScroll()` inside `ReactVirtualScroller.render()`\n      // which is followed by `<VirtualScroller/>`'s `.componentDidUpdate()`\n      // which also calls `.captureScroll()` with the same arguments.\n      // (this is done to prevent scroll Y position from jumping\n      //  when showing the first page of the \"Previous items\",\n      //  see the comments in `ReactVirtualScroller.render()` method).\n\n\n      if (this.restoreScrollAfterPrepend && this.restoreScrollAfterPrepend.previousItems === previousItems && this.restoreScrollAfterPrepend.nextItems === nextItems) {\n        return;\n      }\n\n      this.restoreScrollAfterPrepend = {\n        previousItems: previousItems,\n        nextItems: nextItems,\n        index: firstPreviousItemIndex,\n        visibleAreaTop: this.getItemElement(0).getBoundingClientRect().top\n      };\n    }\n  }, {\n    key: \"updateItems\",\n\n    /**\n     * @deprecated\n     * `.updateItems()` has been renamed to `.setItems()`.\n     */\n    value: function updateItems(newItems, options) {\n      return this.setItems(newItems, options);\n    }\n    /**\n     * Updates `items`. For example, can prepend or append new items to the list.\n     * @param  {any[]} newItems\n     * @param {boolean} [options.preserveScrollPositionOnPrependItems] — Set to `true` to enable \"restore scroll position after prepending items\" feature (could be useful when implementing \"Show previous items\" button).\n     */\n\n  }, {\n    key: \"setItems\",\n    value: function setItems(newItems) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      // * @param  {object} [newCustomState] — If `customState` was passed to `getInitialState()`, this `newCustomState` updates it.\n      var _this$getState9 = this.getState(),\n          previousItems = _this$getState9.items;\n\n      var _this$getState10 = this.getState(),\n          firstShownItemIndex = _this$getState10.firstShownItemIndex,\n          lastShownItemIndex = _this$getState10.lastShownItemIndex,\n          beforeItemsHeight = _this$getState10.beforeItemsHeight,\n          afterItemsHeight = _this$getState10.afterItemsHeight,\n          itemStates = _this$getState10.itemStates,\n          itemHeights = _this$getState10.itemHeights,\n          itemSpacing = _this$getState10.itemSpacing;\n\n      var firstSeenItemIndex = this.firstSeenItemIndex,\n          lastSeenItemIndex = this.lastSeenItemIndex;\n      log(\"~ Update items ~\");\n\n      var _getItemsDiff3 = getItemsDiff(previousItems, newItems),\n          prependedItemsCount = _getItemsDiff3.prependedItemsCount,\n          appendedItemsCount = _getItemsDiff3.appendedItemsCount;\n\n      var isIncrementalUpdate = prependedItemsCount >= 0 || appendedItemsCount >= 0;\n\n      if (isIncrementalUpdate) {\n        if (prependedItemsCount >= 0) {\n          log(\"Prepend\", prependedItemsCount, \"items\");\n          itemHeights = new Array(prependedItemsCount).concat(itemHeights);\n\n          if (itemStates) {\n            itemStates = new Array(prependedItemsCount).concat(itemStates);\n          }\n        }\n\n        if (appendedItemsCount >= 0) {\n          log(\"Append\", appendedItemsCount, \"items\");\n          itemHeights = itemHeights.concat(new Array(appendedItemsCount));\n\n          if (itemStates) {\n            itemStates = itemStates.concat(new Array(appendedItemsCount));\n          }\n        }\n\n        firstShownItemIndex += prependedItemsCount;\n        lastShownItemIndex += prependedItemsCount;\n\n        if (firstSeenItemIndex !== undefined) {\n          firstSeenItemIndex += prependedItemsCount;\n          lastSeenItemIndex += prependedItemsCount;\n        }\n\n        beforeItemsHeight += this.itemHeights.getAverage() * prependedItemsCount;\n        afterItemsHeight += this.itemHeights.getAverage() * appendedItemsCount;\n      } else {\n        log(\"Items have changed, and it's not a simple append and/or prepend: rerender the entire list from scratch.\");\n        log(\"Previous items\", previousItems);\n        log(\"New items\", newItems);\n        firstSeenItemIndex = undefined;\n        lastSeenItemIndex = undefined;\n        itemHeights = new Array(newItems.length);\n        itemStates = new Array(newItems.length);\n\n        if (newItems.length === 0) {\n          firstShownItemIndex = undefined;\n          lastShownItemIndex = undefined;\n        } else {\n          firstShownItemIndex = 0;\n          lastShownItemIndex = this.getLastShownItemIndex(firstShownItemIndex, newItems.length);\n        }\n\n        beforeItemsHeight = 0;\n        afterItemsHeight = 0;\n      } // let customState\n      // `newCustomState` argument is not currently being used.\n      // if (newCustomState) {\n      // \tif (typeof newCustomState === 'function') {\n      // \t\tcustomState = newCustomState(this.getState(), {\n      // \t\t\tprependedCount: isIncrementalUpdate ? undefined : prependedItemsCount,\n      // \t\t\tappendedCount: isIncrementalUpdate ? undefined : appendedItemsCount\n      // \t\t})\n      // \t} else {\n      // \t\tcustomState = newCustomState\n      // \t}\n      // }\n\n\n      log(\"First shown item index\", firstShownItemIndex);\n      log(\"Last shown item index\", lastShownItemIndex);\n      log(\"Before items height\", beforeItemsHeight);\n      log(\"After items height (actual or estimated)\", afterItemsHeight); // Optionally preload items to be rendered.\n\n      this.onBeforeShowItems(newItems, firstShownItemIndex, lastShownItemIndex, firstSeenItemIndex, lastSeenItemIndex); // `preserveScrollPosition` property name is deprecated,\n      // use `preserveScrollPositionOnPrependItems` instead.\n\n      this.preserveScrollPositionOnPrependItems = options.preserveScrollPositionOnPrependItems || options.preserveScrollPosition; // Render.\n\n      this.setState({\n        // ...customState,\n        items: newItems,\n        itemStates: itemStates,\n        itemHeights: itemHeights,\n        firstShownItemIndex: firstShownItemIndex,\n        lastShownItemIndex: lastShownItemIndex,\n        beforeItemsHeight: beforeItemsHeight,\n        afterItemsHeight: afterItemsHeight\n      });\n    }\n  }, {\n    key: \"getItemElement\",\n    value: function getItemElement(i) {\n      return this.getContainerElement().childNodes[i];\n    } // Turns out this optimization won't work\n    // because sometimes item height is an average approximation\n    // and the other times it's the real item height\n    // and sometimes it can change while item's not visible.\n    // /**\n    //  * Measures new \"before\" items height.\n    //  * @param  {number} firstShownItemIndex — New first shown item index.\n    //  * @param  {number} lastShownItemIndex — New last shown item index.\n    //  * @return {number}\n    //  */\n    // getBeforeItemsHeightOptimized(firstShownItemIndex, lastShownItemIndex) {\n    // \t// If the previous and new shown item indexes intersect\n    // \t// then the new \"before\" items height may be calculated\n    // \t// based on the previous \"before\" items height.\n    // \tif (this.getState().averageItemHeight !== undefined &&\n    // \t\tthis.doPrevAndNextItemIndexesIntersect(firstShownItemIndex, lastShownItemIndex)) {\n    // \t\tlet beforeItemsHeight = this.getState().beforeItemsHeight\n    // \t\t// Add all \"before\" will-be-hidden items' height.\n    // \t\tlet i = this.getState().firstShownItemIndex\n    // \t\twhile (i <= this.getState().lastShownItemIndex && i < firstShownItemIndex) {\n    // \t\t\tbeforeItemsHeight += (this.itemHeights.get(i) || this.itemHeights.getAverage())\n    // \t\t\tbeforeItemsHeight += this.getItemSpacing()\n    // \t\t\ti++\n    // \t\t}\n    // \t\t// Subtract all \"before\" will-be-shown items' height.\n    // \t\ti = firstShownItemIndex\n    // \t\twhile (i <= lastShownItemIndex && i < this.getState().firstShownItemIndex) {\n    // \t\t\tbeforeItemsHeight -= (this.itemHeights.get(i) || this.itemHeights.getAverage())\n    // \t\t\tbeforeItemsHeight -= this.getItemSpacing()\n    // \t\t\ti++\n    // \t\t}\n    // \t\treturn beforeItemsHeight\n    // \t}\n    // \t// If the previous and new shown item indexes don't intersect\n    // \t// then re-calculate \"before\" items height.\n    // \telse {\n    // \t\treturn this.getBeforeItemsHeight(firstShownItemIndex, lastShownItemIndex)\n    // \t}\n    // }\n    // Turns out this optimization won't work\n    // because sometimes item height is an average approximation\n    // and the other times it's the real item height\n    // and sometimes it can change while item's not visible.\n    // /**\n    //  * Measures new \"after\" items height.\n    //  * @param  {number} firstShownItemIndex — New first shown item index.\n    //  * @param  {number} lastShownItemIndex — New last shown item index.\n    //  * @return {number}\n    //  */\n    // getAfterItemsHeightOptimized(firstShownItemIndex, lastShownItemIndex) {\n    // \t// If the previous and new shown item indexes intersect\n    // \t// then the new \"after\" items height may be calculated\n    // \t// based on the previous \"after\" items height.\n    // \tif (this.getState().averageItemHeight !== undefined &&\n    // \t\tthis.doPrevAndNextItemIndexesIntersect(firstShownItemIndex, lastShownItemIndex)) {\n    // \t\tlet afterItemsHeight = this.getState().afterItemsHeight\n    // \t\t// Add all \"after\" will-be-hidden items' height.\n    // \t\tlet i = this.getState().lastShownItemIndex\n    // \t\twhile (i >= this.getState().firstShownItemIndex && i > lastShownItemIndex) {\n    // \t\t\tafterItemsHeight += (this.itemHeights.get(i) || this.itemHeights.getAverage())\n    // \t\t\tafterItemsHeight += this.getItemSpacing()\n    // \t\t\ti--\n    // \t\t}\n    // \t\t// Subtract all \"after\" will-be-shown items' height.\n    // \t\ti = lastShownItemIndex\n    // \t\twhile (i >= firstShownItemIndex && i > this.getState().lastShownItemIndex) {\n    // \t\t\tafterItemsHeight -= (this.itemHeights.get(i) || this.itemHeights.getAverage())\n    // \t\t\tafterItemsHeight -= this.getItemSpacing()\n    // \t\t\ti--\n    // \t\t}\n    // \t\treturn afterItemsHeight\n    // \t}\n    // \t// If the previous and new shown item indexes don't intersect\n    // \t// then re-calculate \"after\" items height.\n    // \telse {\n    // \t\treturn this.getAfterItemsHeight(firstShownItemIndex, lastShownItemIndex)\n    // \t}\n    // }\n    // Was used it `.getBeforeItemsHeightOptimized()` and `.getAfterItemsHeightOptimized()`.\n    // doPrevAndNextItemIndexesIntersect(firstShownItemIndex, lastShownItemIndex) {\n    // \treturn firstShownItemIndex <= this.getState().lastShownItemIndex &&\n    // \t\tlastShownItemIndex >= this.getState().firstShownItemIndex\n    // }\n    // Not implementing the \"delayed\" layout feature for now.\n    // delayLayout(args) {\n    // \t// Suppose there's a \"router\" library which restores scroll position\n    // \t// on \"Back\" navigation but only does so after `componentDidMount()`\n    // \t// is called on the underlying page meaning that by the time\n    // \t// the scroll position is restored the `VirtualScroller` component\n    // \t// has already rendered with previous page's scroll position\n    // \t// resulting in an unnecessary layout. \"Delaying\" layout\n    // \t// means that the layout is called in a `setTimeout(..., 0)` call\n    // \t// rather than immediately on mount.\n    // \tif (this.shouldDelayLayout) {\n    // \t\tthis.layoutDelayedWithArgs = args\n    // \t\t// Then in `.render()`:\n    // \t\t// if (this.layoutDelayedWithArgs) {\n    // \t\t// \tthis.shouldDelayLayout = false\n    // \t\t// \tsetTimeout(() => {\n    // \t\t// \t\tif (this.isRendered) {\n    // \t\t// \t\t\tthis.onUpdateShownItemIndexes(this.layoutDelayedWithArgs)\n    // \t\t// \t\t\tthis.layoutDelayedWithArgs = undefined\n    // \t\t// \t\t}\n    // \t\t// \t}, 0)\n    // \t\t// }\n    // \t\treturn true\n    // \t}\n    // }\n\n  }]);\n\n  return VirtualScroller;\n}();\n\nexport { VirtualScroller as default };\n\nfunction getRemainderRest(n, divider) {\n  var remainder = n % divider;\n\n  if (remainder > 0) {\n    return divider - remainder;\n  }\n\n  return 0;\n}\n\nvar isArrayEqual = function isArrayEqual(arr1, arr2) {\n  if (Array.isArray(arr1) && Array.isArray(arr2)) {\n    return arr1.filter(function (x) {\n      return !arr2.includes(x);\n    }).concat(arr2.filter(function (x) {\n      return !arr1.includes(x);\n    })).length === 0;\n  }\n\n  return false;\n};\n\nexport function getItemsDiff(previousItems, newItems) {\n  var firstPreviousItemIndex = -1;\n  var lastPreviousItemIndex = -1;\n\n  if (previousItems.length > 0) {\n    firstPreviousItemIndex = newItems.findIndex(function (item) {\n      return item.id && item.id === previousItems[0].id || isArrayEqual(item, previousItems[0]);\n    });\n\n    if (firstPreviousItemIndex >= 0) {\n      if (arePreviousItemsPreserved(previousItems, newItems, firstPreviousItemIndex)) {\n        lastPreviousItemIndex = firstPreviousItemIndex + previousItems.length - 1;\n      }\n    }\n  }\n\n  var isIncrementalUpdate = firstPreviousItemIndex >= 0 || lastPreviousItemIndex >= 0;\n\n  if (isIncrementalUpdate) {\n    return {\n      prependedItemsCount: firstPreviousItemIndex,\n      appendedItemsCount: newItems.length - (lastPreviousItemIndex + 1)\n    };\n  }\n\n  return {\n    prependedItemsCount: -1,\n    appendedItemsCount: -1\n  };\n}\n\nfunction arePreviousItemsPreserved(previousItems, newItems, offset) {\n  // Check each item of the `previousItems` to determine\n  // whether it's an \"incremental\" items update.\n  // (an update when items are prepended or appended)\n  var i = 0;\n\n  while (i < previousItems.length) {\n    if (newItems[offset + i] && newItems[offset + i].id !== previousItems[i].id || newItems[offset + i] && newItems[offset + i][0].id !== previousItems[i][0].id) {\n      return false;\n    }\n\n    i++;\n  }\n\n  return true;\n}\n//# sourceMappingURL=VirtualScroller.js.map","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport VirtualScroller from './VirtualScroller';\nimport log from './log';\nimport { px } from './utility';\n\nvar DOMVirtualScroller =\n/*#__PURE__*/\nfunction () {\n  function DOMVirtualScroller(element, _items, renderItem) {\n    var _this = this;\n\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, DOMVirtualScroller);\n\n    _defineProperty(this, \"onStateChange\", function (state, prevState) {\n      var items = state.items,\n          firstShownItemIndex = state.firstShownItemIndex,\n          lastShownItemIndex = state.lastShownItemIndex,\n          beforeItemsHeight = state.beforeItemsHeight,\n          afterItemsHeight = state.afterItemsHeight;\n      log('~ On state change ~');\n      log('Previous state', prevState);\n      log('New state', state); // Set container padding top and bottom.\n      // Work around `<tbody/>` not being able to have `padding`.\n      // https://gitlab.com/catamphetamine/virtual-scroller/-/issues/1\n      // `this.virtualScroller` hasn't been initialized yet at this stage,\n      // so using `this.tbody` instead of `this.virtualScroller.tbody`.\n\n      if (!_this.tbody) {\n        _this.container.style.paddingTop = px(beforeItemsHeight);\n        _this.container.style.paddingBottom = px(afterItemsHeight);\n      } // Perform an intelligent \"diff\" re-render if the `items` are the same.\n\n\n      var diffRender = prevState && items === prevState.items && items.length > 0; // Remove no longer visible items from the DOM.\n\n      if (diffRender) {\n        log('Incremental rerender'); // Decrement instead of increment here because\n        // `this.container.removeChild()` changes indexes.\n\n        var _i = prevState.lastShownItemIndex;\n\n        while (_i >= prevState.firstShownItemIndex) {\n          if (_i >= firstShownItemIndex && _i <= lastShownItemIndex) {// The item is still visible.\n          } else {\n            log('Remove item index', _i); // The item is no longer visible. Remove it.\n\n            _this.unmountItem(_this.container.childNodes[_i - prevState.firstShownItemIndex]);\n          }\n\n          _i--;\n        }\n      } else {\n        log('Rerender from scratch');\n\n        while (_this.container.firstChild) {\n          _this.unmountItem(_this.container.firstChild);\n        }\n      } // Add newly visible items to the DOM.\n\n\n      var shouldPrependItems = diffRender;\n      var prependBeforeItemElement = shouldPrependItems && _this.container.firstChild;\n      var i = firstShownItemIndex;\n\n      while (i <= lastShownItemIndex) {\n        if (diffRender && i >= prevState.firstShownItemIndex && i <= prevState.lastShownItemIndex) {\n          // The item is already being rendered.\n          // Next items will be appended rather than prepended.\n          if (shouldPrependItems) {\n            shouldPrependItems = false;\n          }\n        } else {\n          var item = _this.renderItem(items[i]);\n\n          if (shouldPrependItems) {\n            log('Prepend item index', i); // Append `item` to `this.container` before the retained items.\n\n            _this.container.insertBefore(item, prependBeforeItemElement);\n          } else {\n            log('Append item index', i); // Append `item` to `this.container`.\n\n            _this.container.appendChild(item);\n          }\n        }\n\n        i++;\n      }\n    });\n\n    _defineProperty(this, \"onUnmount\", function () {\n      console.warn('[virtual-scroller] `.onUnmount()` instance method name is deprecated, use `.stop()` instance method name instead.');\n\n      _this.stop();\n    });\n\n    _defineProperty(this, \"destroy\", function () {\n      console.warn('[virtual-scroller] `.destroy()` instance method name is deprecated, use `.stop()` instance method name instead.');\n\n      _this.stop();\n    });\n\n    _defineProperty(this, \"stop\", function () {\n      _this.virtualScroller.stop();\n    });\n\n    this.container = element;\n    this.renderItem = renderItem;\n\n    var onMount = options.onMount,\n        onItemUnmount = options.onItemUnmount,\n        restOptions = _objectWithoutProperties(options, [\"onMount\", \"onItemUnmount\"]);\n\n    this.onItemUnmount = onItemUnmount;\n    this.tbody = this.container.tagName === 'TBODY';\n    this.virtualScroller = new VirtualScroller(function () {\n      return _this.container;\n    }, _items, _objectSpread({}, restOptions, {\n      tbody: this.tbody,\n      onStateChange: this.onStateChange\n    })); // `onMount()` option is deprecated due to no longer being used.\n    // If someone thinks there's a valid use case for it, create an issue.\n\n    if (onMount) {\n      onMount();\n    }\n\n    this.virtualScroller.listen();\n  }\n\n  _createClass(DOMVirtualScroller, [{\n    key: \"unmountItem\",\n    value: function unmountItem(itemElement) {\n      this.container.removeChild(itemElement);\n\n      if (this.onItemUnmount) {\n        this.onItemUnmount(itemElement);\n      }\n    }\n  }, {\n    key: \"onItemHeightChange\",\n    value: function onItemHeightChange(i) {\n      this.virtualScroller.onItemHeightChange(i);\n    }\n    /**\n     * @deprecated\n     * `.updateItems()` has been renamed to `.setItems()`.\n     */\n\n  }, {\n    key: \"updateItems\",\n    value: function updateItems(newItems, options) {\n      this.setItems(newItems, options);\n    }\n  }, {\n    key: \"setItems\",\n    value: function setItems(newItems, options) {\n      this.virtualScroller.setItems(newItems, options);\n    }\n  }, {\n    key: \"getItemCoordinates\",\n    value: function getItemCoordinates(i) {\n      return this.virtualScroller.getItemCoordinates(i);\n    }\n  }]);\n\n  return DOMVirtualScroller;\n}();\n\nexport { DOMVirtualScroller as default };\n//# sourceMappingURL=DOMVirtualScroller.js.map"],"names":["getNanoSeconds","hrtime","loadTime","moduleLoadTime","nodeLoadTime","upTime","performance","now","module","process","hr","uptime","Date","getTime","call","this","root","window","global","vendors","suffix","raf","caf","i","length","last","id","queue","callback","_now","next","Math","max","setTimeout","cp","slice","cancelled","e","round","push","handle","fn","apply","arguments","object","requestAnimationFrame","cancelAnimationFrame","cancel","delay","startedAt","animationFrame","tick","clear","clearTimeout","timeout","_typeof","obj","Symbol","iterator","constructor","prototype","_possibleConstructorReturn","self","ReferenceError","_assertThisInitialized","_getPrototypeOf","o","Object","setPrototypeOf","getPrototypeOf","__proto__","_setPrototypeOf","p","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","ScrollableContainer","element","value","scrollTop","scrollX","scrollY","scrollTo","offsetWidth","offsetHeight","scrollHeight","scrollableContainerTop","getBoundingClientRect","top","scrollableContainerBorderTopWidth","clientTop","getScrollY","listener","_this","addEventListener","removeEventListener","_onResize","unobserve","_this2","ResizeObserver","resizeObserver","entries","_iterator","_isArray","Array","isArray","_i","done","observe","unlistenWindowResize","ScrollableWindowContainer","onResize","_ScrollableContainer","subClass","superClass","create","_inherits","pageYOffset","innerWidth","innerHeight","document","documentElement","borderTopWidth","body","_onResize2","px","number","toFixed","NOT_SUPPORTED_MESSAGE","_toConsumableArray","arr","arr2","_arrayWithoutHoles","iter","toString","from","_iterableToArray","_nonIterableSpread","log","isDebug","_console","_len","args","_key","console","concat","VirtualScrollerDebug","ItemHeights","getContainerElement","getState","initialize","reset","onStateUpdate","measuredItemsHeight","firstMeasuredItemIndex","undefined","lastMeasuredItemIndex","itemHeights","firstShownItemIndex","container","nodeIndex","childNodes","height","firstItem","secondItem","firstItemRect","spacing","fromIndex","toIndex","itemSpacing","getItemSpacing","previousFirstMeasuredItemIndex","previousLastMeasuredItemIndex","firstMeasuredItemIndexHasBeenUpdated","_getItemHeight","set","previousHeight","get","count","hasOwnProperty","is","x","y","_objectSpread","source","ownKeys","keys","getOwnPropertySymbols","filter","sym","getOwnPropertyDescriptor","forEach","_defineProperty","SCROLLABLE_CONTAINER_RESIZE_DEBOUNCE_INTERVAL","WAIT_FOR_USER_TO_STOP_SCROLLING_TIMEOUT","VirtualScroller","items","func","interval","options","onUpdateShownItemIndexes","reason","updateLayout","event","isRendered","action","shouldUpdateLayoutOnScrollableContainerResize","resized","setState","getInitialLayoutState","newState","prevState","preserveScrollPositionOnPrependItems","previousItems","newItems","prependedItemsCount","getItemsDiff","captureScroll","onStateChange","objA","objB","keysA","keysB","shallowEqual","lastShownItemIndex","onRendered","_getItemsDiff2","appendedItemsCount","onPrepend","firstSeenItemIndex","lastSeenItemIndex","updateSeenItemIndexes","multiRenderLayout","stopMultiRenderLayout","force","onMultiRenderLayoutRendered","_this$getShownItemInd","getShownItemIndexes","redoLayoutAfterRender","beforeItemsHeight","getBeforeItemsHeight","afterItemsHeight","getAfterItemsHeight","updateWillBeHiddenItemHeightsAndState","bypass","getAverage","itemStates","onBeforeShowItems","updateShownItemIndexes","_this$restoreScrollAf","restoreScrollAfterPrepend","index","visibleAreaTop","scrollByY","getItemElement","_ref","getItemsCount","onUserStopsScrollingTimeout","forceRender","latestLayoutVisibleAreaTopAfterIncludingMargin","latestLayoutVisibleAreaBottomAfterIncludingMargin","scrollableContainer","getHeight","onUserStoppedScrolling","updateShownItemIndexesRecursive","customState","preserveScrollPositionAtBottomOnMount","shouldUpdateLayoutOnWindowResize","measureItemsBatchSize","getScrollableContainer","tbody","estimatedItemHeight","onItemInitialRender","onItemFirstRender","preserveScrollPositionOfTheBottomOfTheListOnMount","state","documentMode","Error","error","initialItems","_shouldUpdateLayoutOnWindowResize","item","warn","indexOf","willUpdateState","didUpdateState","firstChild","removeChild","clearElement","scrollableContainerContentHeight","getContentHeight","getInitialState","itemsCount","getLastShownItemIndex","getEstimatedItemHeight","ceil","getEstimatedItemsCount","getMargin","min","getEstimatedItemsCountOnScreen","_toIndex","_i2","_this$getState3","listen","scrollableContainerWidth","getWidth","scrollableContainerHeight","restoreScrollPosition","updateScrollPosition","removeScrollPositionListener","addScrollListener","removeScrollListener","onScroll","scrollableContainerUnlistenResize","classList","add","style","getElementById","createElement","innerText","replace","head","appendChild","addTbodyStyles","updateItemHeights","updateTbodyPadding","bottom","getTopOffset","fullscreenElement","contains","prevScrollableContainerWidth","prevScrollableContainerHeight","stop","watchContainerElementCoordinatesTimer","_this$getState4","setProperty","setTbodyPadding","_this$getState5","update","updateItemHeight","itemState","JSON","stringify","newHeight","j","visibleAreaBottom","listTopOffset","firstNonMeasuredItemIndex","itemsHeight","heightLeft","listHeight","indexes","getVisibleItemIndexes","check","topOffset","watchContainerElementCoordinates","_this$getVisibleAreaB","getVisibleAreaBounds","getItemIndexes","getOffscreenListShownItemIndexes","_this3","restoreScroll","nextItems","firstPreviousItemIndex","setItems","_this$getState10","_getItemsDiff3","preserveScrollPosition","isArrayEqual","arr1","includes","lastPreviousItemIndex","findIndex","offset","arePreviousItemsPreserved","_objectWithoutProperties","excluded","sourceKeys","_objectWithoutPropertiesLoose","sourceSymbolKeys","propertyIsEnumerable","DOMVirtualScroller","_items","renderItem","paddingTop","paddingBottom","diffRender","unmountItem","shouldPrependItems","prependBeforeItemElement","insertBefore","virtualScroller","onMount","onItemUnmount","restOptions","tagName","itemElement","onItemHeightChange","getItemCoordinates"],"mappings":"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"}